﻿@using Microsoft.AspNetCore.Components

@inject ISnackbar Snackbar
@inject APIService apiService
@inject IDialogService DialogService
@inject CookieService cookieService


@if (_isLoaded == true)
{
    <MudDialog>
        <DialogContent>
            <MudGrid Spacing="5">
                <!-- Player Info -->
                <MudItem xs="12" Class="mb-3">
                    @if (IsTeamEvent)
                    {
                        <MudText Typo="Typo.h6"> @_regionName</MudText>
                    }
                    else
                    {
                        <MudText Typo="Typo.h6" Class="mb-2">@_playerName</MudText>
                        <MudText Typo="Typo.caption">Region: @_regionName</MudText>
                    }
                    <MudDivider Class="my-2" />
                </MudItem>

                <!-- Sport Details -->
                <MudItem xs="12" Class="mb-3">
                    <MudStack Spacing="1">
                        <MudGrid Spacing="1">
                            <MudItem xs="12">
                                <MudSelect @bind-Value="_selectedMainCategory" Margin="Margin.Dense"
                                           Label="Event" T="string"
                                           ShrinkLabel Variant="Variant.Outlined" Clearable
                                           ReadOnly="true">
                                    @if (!string.IsNullOrEmpty(_selectedMainCategory))
                                    {
                                        <MudSelectItem Value="@_selectedMainCategory">@_selectedMainCategory</MudSelectItem>
                                    }
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12">
                                <MudSelect Value="@_selectedSubcategoryId"
                                           ValueChanged="@((int? value) => OnSubcategoryChanged(value))"
                                           Margin="Margin.Dense" ReadOnly="@_isSubcategoryLocked"
                                           Label="Category" T="int?"
                                           ShrinkLabel Variant="Variant.Outlined" Clearable>
                                    <MudVirtualize Items="_sportSubcategories" Context="subCategory">
                                        <MudSelectItem T="int?"
                                                       Value="@subCategory.ID">@subCategory.Subcategory</MudSelectItem>
                                    </MudVirtualize>
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12">
                                <MudNumericField @bind-Value="_scoreValue"
                                                 HideSpinButtons="true"
                                                 Label="Score"
                                                 Variant="Variant.Outlined"
                                                 Min="0"
                                                 Max="1000"
                                                 Step="0.1"
                                                 Margin="Margin.Dense"
                                                 Disabled="@_isScoreInputDisabled" />
                            </MudItem>
                        </MudGrid>
                    </MudStack>
                </MudItem>

                @if (_existingScoreId.HasValue && _selectedSubcategoryId.HasValue)
                {
                    @if (ShouldShowMedalTally())
                    {
                        <MudItem xs="12" Class="mb-3">
                            <MudStack Spacing="1">
                                <MudText>Medal Tally</MudText>
                                <MudDivider />
                                <MudGrid Spacing="1" Class="mt-2">
                                    <MudItem xs="12">
                                        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                            <MudItem xs="12" sm="10">
                                                <MudSelect @bind-Value="_selectedMedal"
                                                           Label="Select Medal"
                                                           ShrinkLabel
                                                           Clearable
                                                           T="string"
                                                           Variant="Variant.Outlined"
                                                           Margin="Margin.Dense" FullWidth="true">
                                                    <MudSelectItem Value="@("Gold")">Gold</MudSelectItem>
                                                    <MudSelectItem Value="@("Silver")">Silver</MudSelectItem>
                                                    <MudSelectItem Value="@("Bronze")">Bronze</MudSelectItem>
                                                </MudSelect>
                                            </MudItem>

                                            <MudItem xs="12" sm="2">
                                                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                                    <MudIconButton Icon="@Icons.Material.Filled.Check" Variant="Variant.Filled"
                                                                   Color="Color.Success"
                                                                   OnClick="SaveMedal"
                                                                   Disabled="@(string.IsNullOrEmpty(_selectedMedal) && _existingMedal == null)" />

                                                    @if (_existingMedal != null && !string.IsNullOrEmpty(_existingMedal.Rank))
                                                    {
                                                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Variant="Variant.Filled"
                                                                       Color="Color.Error"
                                                                       OnClick="DeleteMedal" />
                                                    }
                                                </MudStack>
                                            </MudItem>
                                        </MudStack>
                                    </MudItem>
                                </MudGrid>
                            </MudStack>
                        </MudItem>
                    }
                }

            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudButton Variant="Variant.Text" OnClick="ConfirmSaveScore">Save</MudButton>
        </DialogActions>
    </MudDialog>
}

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; }

    [Parameter] public int RegionID { get; set; }
    [Parameter] public string PlayerID { get; set; } = string.Empty;
    [Parameter] public int? EventID { get; set; }
    [Parameter] public EventCallback OnScoreSaved { get; set; }

    [Parameter] public bool IsTeamEvent { get; set; } = false;
    [Parameter] public List<string> TeamPlayerIDs { get; set; } = new();
    [Parameter] public int? TeamID { get; set; }

    [Parameter] public string? ForcedCategoryName { get; set; }

    [Parameter] public bool SaveToLinkedPerformances { get; set; } = false;
    [Parameter] public List<int> LinkedPerformanceIDs { get; set; } = new();

    [Parameter] public bool IsAerobicRegionChampionship { get; set; } = false;

    private string _playerName = "Loading...";
    private string _regionName = "Loading...";
    private double _scoreValue;
    private string? _selectedMainCategory;
    private int? _selectedSubcategoryId;
    private bool _isLoaded = false;
    private int? _existingScoreId;

    private bool _isScoreInputDisabled = false; // Add this flag
    private int? _eliminationRank; // Add this to store current rank
    private int _eventStageId = 0;

    private bool _isSubcategoryLocked = false;

    private List<string> _mainCategories = new();
    private PerformanceBasedDTO.PerformanceEvent? _selectedEvent;
    private List<SportsDTO.SportSubcategories> _sportSubcategories = new();
    private List<SportsDTO.SportSubcategories> _filteredSubcategories = new();
    private int? _opposingTeamId;
    private string _currentUserId = string.Empty;

    private List<PerformanceBasedDTO.PerformanceTeam> _allOpposingTeams = new();
    private List<string> _teamPlayerNames = new();

    private List<SportsDTO.SportGenderCategories> _sportGenderCategories = new();
    private List<SchoolsDTO.SchoolLevels> _schoolLevels = new();
    private int? _selectedSportIDValue;

    private Dictionary<string, int> _teamPerformanceTeamIds = new(); // PlayerID -> PerformanceTeamID
    private List<int> _existingTeamScoreIds = new();                 // score IDs for this team+subcategory
    private Dictionary<int, PerformanceBasedDTO.PerformanceScore> _existingTeamScoresByPerfTeamId = new(); // perfTeamId -> score row

    protected override async Task OnInitializedAsync()
    {
        await LoadInitialData();
        _isLoaded = true;
    }

    private async Task LoadInitialData()
    {
        try
        {
            await GetCurrentUserIdAsync();
            await LoadAllOpposingTeams();
            await LoadEventData();
            await LoadPlayerAndRegionData();
            await LoadSportData();
            await LoadOpposingTeam();
            await ApplyForcedCategoryIfAny();

            if (!_isSubcategoryLocked)
                await AutoSelectSubcategory();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading data: {ex.Message}", Severity.Error);
        }
    }

    private async Task<string> GetCurrentUserIdAsync()
    {
        try
        {
            // Try to get user ID from cookie first
            var userId = await cookieService.GetCookie("userID");

            if (!string.IsNullOrEmpty(userId))
            {
                return userId;
            }

            // If no user ID in cookie, check for token
            var token = await cookieService.GetCookie("authenticationToken");
            if (string.IsNullOrEmpty(token))
            {
                Snackbar.Add("User not authenticated. Please log in.", Severity.Error);
                return string.Empty;
            }

            Snackbar.Add("Unable to retrieve user ID. Please log in again.", Severity.Warning);
            return string.Empty;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error getting user ID: {ex.Message}", Severity.Error);
            return string.Empty;
        }
    }

    private async Task LoadEventData()
    {
        try
        {
            if (!EventID.HasValue)
            {
                Snackbar.Add("No event ID provided", Severity.Error);
                return;
            }

            string eventUrl = $"/PerformanceBased/PerformanceEvent/{EventID.Value}";
            _selectedEvent = await apiService.GetSingleAsync<PerformanceBasedDTO.PerformanceEvent>(eventUrl);

            if (_selectedEvent == null)
            {
                var eventList = await apiService.GetAsync<PerformanceBasedDTO.PerformanceEvent>(eventUrl);
                _selectedEvent = eventList?.FirstOrDefault();
            }

            if (_selectedEvent != null)
            {
                _selectedMainCategory = _selectedEvent.MainCategory;
                _selectedSportIDValue = _selectedEvent.SportID;
                _eventStageId = _selectedEvent.StageID;

                // Load the necessary data for filtering
                await GetGenderCategoriesAsync();
                await GetSchoolLevelsAsync();

                // Now filter subcategories using the event data
                await FilterSubcategoriesByEvent();
            }
            else
            {
                Snackbar.Add($"Event not found for ID: {EventID.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading event data: {ex.Message}", Severity.Error);
        }
    }

    private async Task FilterSubcategoriesByEvent()
    {
        if (_selectedEvent == null) return;

        try
        {
            // Use the specific filtering method with event data
            await GetSportSubCategoriesAsync();

            if (!string.IsNullOrEmpty(_selectedMainCategory))
            {
                await FilterSubcategoriesByMainCategory();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error filtering subcategories: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadPlayerAndRegionData()
    {
        if (IsTeamEvent && TeamPlayerIDs.Any())
        {
            await LoadTeamPlayerNames();
        }
        else if (!string.IsNullOrEmpty(PlayerID) && EventID != null)
        {
            try
            {
                string playerUrl = $"/Profiles/Player?id={PlayerID}";
                var playerResult = await apiService.GetAsync<ProfilePlayersDTO.Players>(playerUrl);
                var player = playerResult?.FirstOrDefault();

                if (player != null)
                {
                    _playerName = $"{player.FirstName} {player.LastName}";
                }
                else
                {
                    _playerName = "Player not found";
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error loading player data: {ex.Message}", Severity.Error);
            }
        }

        try
        {
            string regionUrl = $"/Schools/Regions?id={RegionID}";
            var regionResult = await apiService.GetAsync<SchoolsDTO.SchoolRegions>(regionUrl);
            var region = regionResult?.FirstOrDefault();

            if (region != null)
            {
                _regionName = region.Abbreviation ?? region.Region;
            }
            else
            {
                _regionName = "Region not found";
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading region data: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadTeamPlayerNames()
    {
        _teamPlayerNames = new List<string>();

        foreach (var playerId in TeamPlayerIDs)
        {
            try
            {
                string playerUrl = $"/Profiles/Player?id={playerId}";
                var playerResult = await apiService.GetAsync<ProfilePlayersDTO.Players>(playerUrl);
                var player = playerResult?.FirstOrDefault();

                if (player != null)
                {
                    _teamPlayerNames.Add($"{player.FirstName} {player.LastName}");
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error loading team player {playerId}: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task LoadOpposingTeam()
    {
        if (EventID == null) return;

        try
        {
            string url = $"/PerformanceBased/OpposingTeams/{EventID}";
            var teams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(url)
                       ?? new List<PerformanceBasedDTO.PerformanceTeam>();

            if (IsTeamEvent)
            {
                List<PerformanceBasedDTO.PerformanceTeam> members = new();

                // 1) Prefer TeamID (ideal)
                if (TeamID.HasValue)
                {
                    members = teams
                        .Where(t => t.RegionID == RegionID
                                 && t.TeamID == TeamID
                                 && t.PerformanceID == EventID)
                        .ToList();
                }

                // 2) Fallback using TeamPlayerIDs
                if (!members.Any() && TeamPlayerIDs != null && TeamPlayerIDs.Any())
                {
                    members = teams
                        .Where(t => t.PerformanceID == EventID
                                 && t.RegionID == RegionID
                                 && TeamPlayerIDs.Contains(t.PlayerID))
                        .ToList();

                    if (!TeamID.HasValue && members.Any())
                        TeamID = members.First().TeamID;
                }

                if (!members.Any())
                {
                    Snackbar.Add("Could not find team members for this event/region.", Severity.Warning);
                    return;
                }

                // ✅ Build lookup needed by SaveScore Team logic
                _teamPerformanceTeamIds = members
                    .Where(m => !string.IsNullOrWhiteSpace(m.PlayerID))
                    .GroupBy(m => m.PlayerID)
                    .ToDictionary(g => g.Key, g => g.First().ID);

                // Keep one representative opposingTeamId (some parts still use it)
                _opposingTeamId = members.First().ID;
                return;
            }

            // ✅ Individual
            var team = teams.FirstOrDefault(t =>
                t.RegionID == RegionID &&
                t.PlayerID == PlayerID &&
                t.PerformanceID == EventID);

            if (team != null)
            {
                _opposingTeamId = team.ID;
                TeamID = team.TeamID; // might still be null
            }
            else
            {
                Snackbar.Add("Could not find team information", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading team data: {ex.Message}", Severity.Error);
        }
    }


    private async Task LoadSportData()
    {
        try
        {
            // If we haven't loaded specific subcategories yet, load all as fallback
            if (!_sportSubcategories.Any())
            {
                string subcategoriesUrl = "/Sports/Subcategories";
                _sportSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(subcategoriesUrl)
                                      ?? new List<SportsDTO.SportSubcategories>();
            }

            LoadMainCategories();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading sport data: {ex.Message}", Severity.Error);
        }
    }

    private void LoadMainCategories()
    {
        _mainCategories = _sportSubcategories
            .Where(sc => !string.IsNullOrEmpty(sc.MainCategory))
            .Select(sc => sc.MainCategory!)
            .Distinct()
            .ToList();
    }

    private async Task LoadExistingScore()
    {
        if (EventID == null || !_selectedSubcategoryId.HasValue) return;

        try
        {
            string url = $"/PerformanceScore/Score/{EventID}";
            var scores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(url)
                        ?? new List<PerformanceBasedDTO.PerformanceScore>();

            _existingTeamScoreIds = new();
            _existingTeamScoresByPerfTeamId = new();

            if (IsTeamEvent && TeamID.HasValue)
            {
                // ✅ Get ALL score rows for this Team + Subcategory
                var teamScores = scores
                    .Where(s => s.TeamID == TeamID
                             && s.SportSubcategoryID == _selectedSubcategoryId.Value)
                    .ToList();

                if (!teamScores.Any())
                {
                    _existingScoreId = null;
                    _scoreValue = 0;
                    _existingMedal = null;
                    _selectedMedal = null;
                    await CheckEliminationRankAndPermission();
                    StateHasChanged();
                    return;
                }

                _existingTeamScoreIds = teamScores.Select(s => s.ID).ToList();
                _existingTeamScoresByPerfTeamId = teamScores.ToDictionary(s => s.PerformanceTeamID, s => s);

                // ✅ Use one representative value for UI
                _existingScoreId = teamScores.First().ID;
                _scoreValue = (double)teamScores.First().Score;

                await LoadExistingMedal(); // if you will also implement team-medal later
                await CheckEliminationRankAndPermission();
                StateHasChanged();
                return;
            }

            // ✅ Individual
            var existingScore = scores.FirstOrDefault(s =>
                s.PerformanceTeamID == _opposingTeamId &&
                s.SportSubcategoryID == _selectedSubcategoryId.Value &&
                !s.TeamID.HasValue);

            if (existingScore != null)
            {
                _existingScoreId = existingScore.ID;
                _scoreValue = (double)existingScore.Score;
                await LoadExistingMedal();
            }
            else
            {
                _existingScoreId = null;
                _scoreValue = 0;
                _existingMedal = null;
                _selectedMedal = null;
            }

            await CheckEliminationRankAndPermission();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading existing score: {ex.Message}", Severity.Error);
            _existingScoreId = null;
            _scoreValue = 0;
            _existingMedal = null;
            _selectedMedal = null;
            _existingTeamScoreIds = new();
            _existingTeamScoresByPerfTeamId = new();
            StateHasChanged();
        }
    }


    private async Task CheckEliminationRankAndPermission()
    {
        if (_eventStageId != 4)
        {
            _isScoreInputDisabled = false;
            _eliminationRank = null;
            return;
        }

        try
        {
            if (_selectedEvent == null) return;

            int? eliminationEventId = await GetEliminationStageEventId();

            if (!eliminationEventId.HasValue)
            {
                _isScoreInputDisabled = false;
                _eliminationRank = null;
                return;
            }

            _eliminationRank = await GetPlayerEliminationRank(eliminationEventId.Value);

            if (_eliminationRank.HasValue && _eliminationRank.Value >= 9)
            {
                _isScoreInputDisabled = true;
            }
            else
            {

                _isScoreInputDisabled = false;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error checking elimination rank: {ex.Message}", Severity.Error);
            _isScoreInputDisabled = false;
            _eliminationRank = null;
        }
    }

    private async Task<int?> GetEliminationStageEventId()
    {
        try
        {
            if (_selectedEvent == null) return null;

            var parameters = new List<string>();

            if (_selectedEvent.SportID.HasValue)
                parameters.Add($"sportID={_selectedEvent.SportID}");

            if (!string.IsNullOrEmpty(_selectedMainCategory))
                parameters.Add($"mainCategory={Uri.EscapeDataString(_selectedMainCategory)}");

            if (_selectedEvent.LevelID.HasValue)
                parameters.Add($"schoolLevelID={_selectedEvent.LevelID}");

            if (_selectedEvent.GenderID.HasValue)
                parameters.Add($"genderID={_selectedEvent.GenderID}");

            parameters.Add($"stageID=1");

            string url = "/PerformanceBased/PerformanceEvents";
            if (parameters.Any())
                url += "?" + string.Join("&", parameters);

            var eliminationEvents = await apiService.GetAsync<PerformanceBasedDTO.PerformanceEvent>(url);

            return eliminationEvents?.FirstOrDefault()?.ID;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error finding elimination stage: {ex.Message}", Severity.Warning);
            return null;
        }
    }

    private async Task<int?> GetPlayerEliminationRank(int eliminationEventId)
    {
        try
        {
            string teamUrl = $"/PerformanceBased/OpposingTeams/{eliminationEventId}";
            var teams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(teamUrl);

            PerformanceBasedDTO.PerformanceTeam team;

            if (IsTeamEvent && TeamID.HasValue)
            {
                team = teams?.FirstOrDefault(t =>
                    t.RegionID == RegionID &&
                    t.TeamID == TeamID &&
                    t.PerformanceID == eliminationEventId);
            }
            else
            {
                team = teams?.FirstOrDefault(t =>
                    t.RegionID == RegionID &&
                    t.PlayerID == PlayerID &&
                    t.PerformanceID == eliminationEventId);
            }

            if (team == null)
            {
                return null;
            }

            string scoresUrl = $"/PerformanceScore/Score/{eliminationEventId}";
            var scores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(scoresUrl)
                         ?? new List<PerformanceBasedDTO.PerformanceScore>();

            var eliminationScore = scores.FirstOrDefault(s =>
                s.PerformanceTeamID == team.ID &&
                s.SportSubcategoryID == _selectedSubcategoryId &&
                ((IsTeamEvent && s.TeamID.HasValue) || (!IsTeamEvent && !s.TeamID.HasValue)));

            return eliminationScore?.Rank;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error getting elimination rank: {ex.Message}", Severity.Warning);
            return null;
        }
    }

    private async Task OnSubcategoryChanged(int? newValue)
    {
        _selectedSubcategoryId = newValue;

        _scoreValue = 0;
        _existingScoreId = null;
        _existingMedal = null;
        _selectedMedal = null;

        if (_selectedSubcategoryId.HasValue && _opposingTeamId.HasValue)
        {
            await LoadExistingScore();
        }
        else
        {
            StateHasChanged(); // Ensure UI updates even if we don't load
        }
    }

    private async Task FilterSubcategoriesByMainCategory()
    {
        if (string.IsNullOrEmpty(_selectedMainCategory))
        {
            _filteredSubcategories = new List<SportsDTO.SportSubcategories>();
            return;
        }

        _filteredSubcategories = _sportSubcategories
            .Where(sc => sc.MainCategory == _selectedMainCategory)
            .ToList();

        StateHasChanged();
    }

    private async Task GetGenderCategoriesAsync()
    {
        try
        {
            string url = "/Sports/GenderCategories";
            _sportGenderCategories = await apiService.GetAsync<SportsDTO.SportGenderCategories>(url)
                                     ?? new List<SportsDTO.SportGenderCategories>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading gender categories: {ex.Message}", Severity.Error);
        }
    }

    private async Task GetSchoolLevelsAsync()
    {
        try
        {
            string url = "/Schools/Levels";
            _schoolLevels = await apiService.GetAsync<SchoolsDTO.SchoolLevels>(url)
                            ?? new List<SchoolsDTO.SchoolLevels>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading school levels: {ex.Message}", Severity.Error);
        }
    }

    private async Task GetSportSubCategoriesAsync()
    {
        if (_selectedEvent == null) return;

        try
        {
            var parameters = new List<string>();

            if (_selectedEvent.SportID.HasValue)
                parameters.Add($"sportID={_selectedEvent.SportID}");

            if (_selectedEvent.LevelID.HasValue)
                parameters.Add($"schoolLevelID={_selectedEvent.LevelID}");

            if (_selectedEvent.GenderID.HasValue)
                parameters.Add($"sportGenderCategoryID={_selectedEvent.GenderID}");

            if (!string.IsNullOrEmpty(_selectedMainCategory))
                parameters.Add($"mainCategory={Uri.EscapeDataString(_selectedMainCategory)}");

            string url = "/Sports/Subcategories";
            if (parameters.Any())
                url += "?" + string.Join("&", parameters);

            var filteredSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(url);

            if (filteredSubcategories != null && filteredSubcategories.Any())
            {
                _sportSubcategories = filteredSubcategories;
            }
            else
            {
                string fallbackUrl = "/Sports/Subcategories";
                _sportSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(fallbackUrl)
                                      ?? new List<SportsDTO.SportSubcategories>();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading sport subcategories: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadAllOpposingTeams()
    {
        if (!EventID.HasValue) return;

        try
        {
            string url = $"/PerformanceBased/OpposingTeams/{EventID}";
            _allOpposingTeams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(url)
                                ?? new List<PerformanceBasedDTO.PerformanceTeam>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading all opposing teams: {ex.Message}", Severity.Warning);
        }
    }

    private int? GetPlayerCountPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        if (_allOpposingTeams == null || evt?.ID == null) return null;

        // Group by RegionID and TeamID to get unique teams
        var teamGroups = _allOpposingTeams
            .Where(team => team.PerformanceID == evt.ID)
            .GroupBy(team => new { team.RegionID, team.TeamID })
            .ToList();

        if (!teamGroups.Any()) return null;

        // For individual events (no TeamID), count distinct players per region
        if (!IsTeamEvent)
        {
            var regionGroups = _allOpposingTeams
                .Where(team => team.PerformanceID == evt.ID)
                .GroupBy(team => team.RegionID)
                .ToList();

            return regionGroups.FirstOrDefault()?.Count() ?? 0;
        }

        // For team events, count players in each team and find the most common count
        var playerCounts = teamGroups
            .Select(group => group.Count())

            .Distinct()
            .ToList();

        // If all teams have the same player count, return that
        if (playerCounts.Count == 1)
        {
            return playerCounts.First();
        }

        // Otherwise, find the most frequent player count
        var mostFrequentCount = teamGroups
            .GroupBy(group => group.Count())
            .OrderByDescending(g => g.Count())
            .FirstOrDefault()?.Key;

        return mostFrequentCount;
    }

    private bool HasTwoPlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount == 2;
    }

    private bool HasThreePlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount == 3;
    }

    private bool HasFiveToEightPlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount >= 5 && playerCount <= 8;
    }

    private async Task ConfirmSaveScore()
    {
        if (!_selectedSubcategoryId.HasValue || _scoreValue <= 0 || !_opposingTeamId.HasValue)
        {
            Snackbar.Add("Please select a category and enter a valid score", Severity.Warning);
            return;
        }

        string action = _existingScoreId.HasValue ? "update" : "add";

        bool? result = await DialogService.ShowMessageBox(
            title: "Confirm Save Score",
            message: $"Are you sure you want to {action} this score?",
            yesText: "Yes",
            cancelText: "Cancel"
        );

        if (result == true)
        {
            await SaveScore();
        }
    }

    private async Task SaveScore()
    {
        try
        {
            if (!_selectedSubcategoryId.HasValue || _scoreValue <= 0)
            {
                Snackbar.Add("Please select a category and enter a valid score", Severity.Warning);
                return;
            }

            if (_isScoreInputDisabled)
            {
                Snackbar.Add("Scoring is disabled for this entry.", Severity.Warning);
                return;
            }

            if (!EventID.HasValue)
            {
                Snackbar.Add("No event selected.", Severity.Error);
                return;
            }

            var currentUserId = await GetCurrentUserIdAsync();

            // ================================
            // ✅ TEAM SAVE (requires TeamID passed in)
            // ================================
            if (IsTeamEvent)
            {
                if (!TeamID.HasValue)
                {
                    Snackbar.Add("No TeamID found. Please click 'Set as Team' first.", Severity.Warning);
                    return;
                }

                // Save to linked performances (for non-aerobic combined cases)
                var performanceIdsToSave =
                    (SaveToLinkedPerformances && LinkedPerformanceIDs != null && LinkedPerformanceIDs.Any())
                        ? LinkedPerformanceIDs.Distinct().ToList()
                        : GetPerformanceIdsToSave();

                int totalSuccess = 0;
                int totalAttempt = 0;

                foreach (var perfId in performanceIdsToSave)
                {
                    string teamUrl = $"/PerformanceBased/OpposingTeams/{perfId}";
                    var teamsForPerf = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(teamUrl)
                                     ?? new List<PerformanceBasedDTO.PerformanceTeam>();

                    var members = teamsForPerf
                        .Where(t => t.RegionID == RegionID && t.TeamID == TeamID.Value)
                        .ToList();

                    if (!members.Any())
                        continue;

                    // Dedupe (player can appear multiple times)
                    var perfTeamIds = members
                        .Where(m => m.ID > 0)
                        .Select(m => m.ID)
                        .Distinct()
                        .ToList();

                    string getUrl = $"/PerformanceScore/Score/{perfId}";
                    var allScores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(getUrl)
                                   ?? new List<PerformanceBasedDTO.PerformanceScore>();

                    foreach (var perfTeamId in perfTeamIds)
                    {
                        totalAttempt++;

                        var existing = allScores.FirstOrDefault(s =>
                            s.PerformanceTeamID == perfTeamId &&
                            s.SportSubcategoryID == _selectedSubcategoryId.Value &&
                            s.TeamID.HasValue &&
                            s.TeamID.Value == TeamID.Value);

                        var scoreData = new PerformanceBasedDTO.PerformanceScore
                        {
                            PerformanceID = perfId,
                            PerformanceTeamID = perfTeamId,
                            SportSubcategoryID = _selectedSubcategoryId.Value,
                            Score = (decimal)_scoreValue,
                            Rank = 0,
                            UserID = currentUserId,
                            UpdatedAt = DateTime.Now,
                            TeamID = TeamID.Value
                        };

                        if (existing != null)
                        {
                            scoreData.ID = existing.ID;
                            var ok = await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                                $"/PerformanceScore/Score/{existing.ID}", scoreData);

                            if (ok) totalSuccess++;
                        }
                        else
                        {
                            var created = await apiService.PostAsync<PerformanceBasedDTO.PerformanceScore>(
                                "/PerformanceScore/Score", scoreData);

                            if (created != null) totalSuccess++;
                        }
                    }

                    await CalculateAndUpdateRanks(perfId);
                }

                if (totalSuccess > 0)
                {
                    Snackbar.Add($"Team score saved for {totalSuccess}/{totalAttempt} row(s).", Severity.Success);
                    MudDialog.Close(DialogResult.Ok(true));
                }
                else
                {
                    Snackbar.Add("Failed to save team score.", Severity.Error);
                }

                return;
            }

            // ================================
            // ✅ INDIVIDUAL SAVE
            // ================================
            if (!_opposingTeamId.HasValue)
            {
                Snackbar.Add("Player team info not found.", Severity.Warning);
                return;
            }

            var individualScore = new PerformanceBasedDTO.PerformanceScore
            {
                PerformanceID = EventID.Value,
                PerformanceTeamID = _opposingTeamId.Value,
                SportSubcategoryID = _selectedSubcategoryId.Value,
                Score = (decimal)_scoreValue,
                Rank = 0,
                UserID = currentUserId,
                UpdatedAt = DateTime.Now,
                TeamID = null
            };

            bool success;

            if (_existingScoreId.HasValue)
            {
                individualScore.ID = _existingScoreId.Value;
                success = await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                    $"/PerformanceScore/Score/{_existingScoreId.Value}", individualScore);
            }
            else
            {
                var created = await apiService.PostAsync<PerformanceBasedDTO.PerformanceScore>(
                    "/PerformanceScore/Score", individualScore);

                success = created != null;
            }

            if (success)
            {
                Snackbar.Add("Score saved successfully!", Severity.Success);
                await CalculateAndUpdateRanks();
                MudDialog.Close(DialogResult.Ok(true));
            }
            else
            {
                Snackbar.Add("Failed to save score", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving score: {ex.Message}", Severity.Error);
        }
    }

    private Task CalculateAndUpdateRanks() => CalculateAndUpdateRanks(EventID);


    private async Task CalculateAndUpdateRanks(int? performanceId)
    {
        if (!performanceId.HasValue || !_selectedSubcategoryId.HasValue) return;

        try
        {
            string url = $"/PerformanceScore/Score/{performanceId.Value}";
            var allScores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(url)
                            ?? new List<PerformanceBasedDTO.PerformanceScore>();

            var scores = allScores
                .Where(s => s.SportSubcategoryID == _selectedSubcategoryId.Value)
                .ToList();

            if (!scores.Any()) return;

            // TEAM ranking (unchanged)
            var teamScores = scores.Where(s => s.TeamID.HasValue).ToList();
            if (teamScores.Any())
            {
                var teamRep = teamScores
                    .GroupBy(s => s.TeamID!.Value)
                    .Select(g => new { TeamID = g.Key, Score = g.Max(x => x.Score) })
                    .OrderByDescending(x => x.Score)
                    .ToList();

                int rank = 1;
                decimal? prev = null;
                var teamRankMap = new Dictionary<int, int>();

                foreach (var t in teamRep)
                {
                    if (prev != null && t.Score != prev) rank++;
                    if (prev == null) rank = 1;

                    teamRankMap[t.TeamID] = rank;
                    prev = t.Score;
                }

                foreach (var row in teamScores)
                {
                    row.Rank = teamRankMap[row.TeamID!.Value];
                    await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                        $"/PerformanceScore/Score/{row.ID}", row);
                }
            }

            // INDIV ranking (unchanged)
            var indivScores = scores.Where(s => !s.TeamID.HasValue).ToList();
            if (indivScores.Any())
            {
                var ordered = indivScores.OrderByDescending(s => s.Score).ToList();

                int rank = 1;
                decimal? prev = null;

                for (int i = 0; i < ordered.Count; i++)
                {
                    if (prev != null && ordered[i].Score != prev) rank = i + 1;
                    if (prev == null) rank = 1;

                    ordered[i].Rank = rank;
                    prev = ordered[i].Score;
                }

                foreach (var row in ordered)
                {
                    await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                        $"/PerformanceScore/Score/{row.ID}", row);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error calculating ranks: {ex.Message}", Severity.Error);
        }
    }


    //MEDAL TALLY

    private string? _selectedMedal;
    private EventsDTO.EventVersusTeams? _existingMedal;
    private List<EventsDTO.EventVersusTeams> _existingTeamMedals = new();


    private async Task LoadExistingMedal()
    {
        _existingMedal = null;
        _existingTeamMedals = new();
        _selectedMedal = null;

        try
        {
            // ✅ TEAM: load medal by TeamID + PerformanceID (recommended)
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                // BEST: have an endpoint that supports this query:
                // /Events/VersusTeams?performanceID=xx&teamID=yy
                string url = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
                var medals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(url)
                             ?? new List<EventsDTO.EventVersusTeams>();

                _existingTeamMedals = medals;

                // representative medal for UI
                var rep = medals.FirstOrDefault(m => !string.IsNullOrEmpty(m.Rank));
                _existingMedal = rep;
                _selectedMedal = rep?.Rank;

                StateHasChanged();
                return;
            }

            // ✅ INDIVIDUAL: existing logic (by PerformanceScoreID)
            if (!_existingScoreId.HasValue) return;

            string url2 = $"/Events/VersusTeams?performanceScoreID={_existingScoreId.Value}";
            var medals2 = await apiService.GetAsync<EventsDTO.EventVersusTeams>(url2);

            _existingMedal = medals2?.FirstOrDefault();
            _selectedMedal = _existingMedal?.Rank;

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading medal data: {ex.Message}", Severity.Error);
            _existingMedal = null;
            _existingTeamMedals = new();
            _selectedMedal = null;
        }
    }


    private async Task SaveMedal()
    {
        try
        {
            // If no medal selected => behave like delete
            if (string.IsNullOrEmpty(_selectedMedal))
            {
                if ((IsTeamEvent && _existingTeamMedals.Any()) || (!IsTeamEvent && _existingMedal != null))
                {
                    await DeleteMedal();
                    return;
                }

                Snackbar.Add("Please select a medal or choose 'No Medal' to remove", Severity.Warning);
                return;
            }

            // ================================
            // ✅ SPECIAL CASE:
            // WAG C1/C2 Team Championship medal propagation (linked performances)
            // ================================
            if (!string.IsNullOrWhiteSpace(ForcedCategoryName) &&
                ForcedCategoryName.Contains("Team Championship", StringComparison.OrdinalIgnoreCase) &&
                SaveToLinkedPerformances &&
                LinkedPerformanceIDs != null && LinkedPerformanceIDs.Any())
            {
                await SaveLinkedTeamChampionshipMedal();
                await LoadExistingMedal();
                return;
            }

            // ================================
            // ✅ TEAM
            // ================================
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                if (_existingTeamScoreIds == null || !_existingTeamScoreIds.Any())
                {
                    Snackbar.Add("No team score rows found. Save team score first.", Severity.Warning);
                    return;
                }

                if (_existingTeamMedals == null || !_existingTeamMedals.Any())
                {
                    string loadUrl = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
                    _existingTeamMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                                         ?? new List<EventsDTO.EventVersusTeams>();
                }

                int successCount = 0;

                foreach (var scoreId in _existingTeamScoreIds.Distinct())
                {
                    var existing = _existingTeamMedals.FirstOrDefault(m => m.PerformanceScoreID == scoreId);

                    var medalTally = new EventsDTO.EventVersusTeams
                    {
                        PerformanceID = EventID.Value,
                        TeamID = TeamID.Value,
                        PerformanceScoreID = scoreId,
                        SchoolRegionID = RegionID,
                        Score = null,
                        Rank = _selectedMedal,
                        RecentUpdateAt = DateTime.Now
                    };

                    if (existing != null)
                    {
                        medalTally.ID = existing.ID;
                        var ok = await apiService.PutAsync<EventsDTO.EventVersusTeams>(
                            $"/Events/VersusTeams/{existing.ID}", medalTally);

                        if (ok) successCount++;
                    }
                    else
                    {
                        var created = await apiService.PostAsync<EventsDTO.EventVersusTeams>(
                            "/Events/VersusTeams", medalTally);

                        if (created != null) successCount++;
                    }
                }

                if (successCount > 0)
                {
                    Snackbar.Add($"Team medal saved for {successCount} player(s).", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to save team medal.", Severity.Error);
                }

                return;
            }

            // ================================
            // ✅ INDIVIDUAL
            // ================================
            if (!_existingScoreId.HasValue)
            {
                Snackbar.Add("No score exists to assign medal to", Severity.Warning);
                return;
            }

            var medalSingle = new EventsDTO.EventVersusTeams
            {
                PerformanceID = EventID,
                TeamID = null,
                PerformanceScoreID = _existingScoreId.Value,
                SchoolRegionID = RegionID,
                Score = null,
                Rank = _selectedMedal,
                RecentUpdateAt = DateTime.Now
            };

            if (_existingMedal != null)
            {
                medalSingle.ID = _existingMedal.ID;
                var ok = await apiService.PutAsync<EventsDTO.EventVersusTeams>(
                    $"/Events/VersusTeams/{_existingMedal.ID}", medalSingle);

                if (ok)
                {
                    Snackbar.Add("Medal updated successfully!", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to update medal", Severity.Error);
                }
            }
            else
            {
                var created = await apiService.PostAsync<EventsDTO.EventVersusTeams>(
                    "/Events/VersusTeams", medalSingle);

                if (created != null)
                {
                    Snackbar.Add("Medal assigned successfully!", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to assign medal", Severity.Error);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving medal: {ex.Message}", Severity.Error);
        }
    }

    // private async Task DeleteMedal()
    // {
    //     bool? result = await DialogService.ShowMessageBox(
    //         title: "Confirm Delete Medal",
    //         message: "Are you sure you want to delete this medal?",
    //         yesText: "Yes",
    //         cancelText: "Cancel"
    //     );

    //     if (result != true) return;

    //     try
    //     {
    //         // ✅ TEAM delete: delete all medals for this team (either by loaded list, or fetch by performance+team)
    //         if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
    //         {
    //             if (_existingTeamMedals == null || !_existingTeamMedals.Any())
    //             {
    //                 string loadUrl = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
    //                 _existingTeamMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
    //                                      ?? new List<EventsDTO.EventVersusTeams>();
    //             }

    //             int deleted = 0;

    //             foreach (var medal in _existingTeamMedals)
    //             {
    //                 var ok = await apiService.DeleteAsync($"/Events/VersusTeams/{medal.ID}");
    //                 if (ok) deleted++;
    //             }

    //             if (deleted > 0)
    //             {
    //                 Snackbar.Add($"Team medal deleted ({deleted} record(s)).", Severity.Success);
    //             }
    //             else
    //             {
    //                 Snackbar.Add("No team medals deleted.", Severity.Warning);
    //             }

    //             _existingTeamMedals = new();
    //             _existingMedal = null;
    //             _selectedMedal = null;
    //             StateHasChanged();
    //             return;
    //         }

    //         // ✅ INDIVIDUAL delete
    //         if (_existingMedal == null) return;

    //         var success = await apiService.DeleteAsync($"/Events/VersusTeams/{_existingMedal.ID}");

    //         if (success)
    //         {
    //             Snackbar.Add("Medal deleted successfully.", Severity.Success);
    //             _existingMedal = null;
    //             _selectedMedal = null;
    //             StateHasChanged();
    //         }
    //         else
    //         {
    //             Snackbar.Add("Failed to delete medal.", Severity.Error);
    //         }
    //     }
    //     catch (Exception ex)
    //     {
    //         Snackbar.Add($"Error deleting medal: {ex.Message}", Severity.Error);
    //     }
    // }

    private async Task DeleteMedal()
    {
        bool? result = await DialogService.ShowMessageBox(
            title: "Confirm Delete Medal",
            message: "Are you sure you want to delete this medal?",
            yesText: "Yes",
            cancelText: "Cancel"
        );

        if (result != true) return;

        try
        {
            // ================================
            // ✅ SPECIAL CASE:
            // WAG C1/C2 Team Championship medal delete propagation (linked performances)
            // ================================
            if (!string.IsNullOrWhiteSpace(ForcedCategoryName) &&
                ForcedCategoryName.Contains("Team Championship", StringComparison.OrdinalIgnoreCase) &&
                SaveToLinkedPerformances &&
                LinkedPerformanceIDs != null && LinkedPerformanceIDs.Any())
            {
                await DeleteLinkedTeamChampionshipMedal();
                await LoadExistingMedal();
                return;
            }

            // ✅ TEAM delete: delete all medals for this team
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                // ✅ If this dialog is used for a COMBINED EVENT, match SAVE behavior:
                // delete medals across ALL linked performance IDs (both combined events)
                var performanceIds = GetPerformanceIdsToSave();

                var deletedIds = new HashSet<int>();
                int deleted = 0;

                foreach (var perfId in performanceIds.Distinct())
                {
                    // Prefer a team-scoped query (keeps it fast + safe)
                    string loadUrl = $"/Events/VersusTeams?performanceID={perfId}&teamID={TeamID.Value}";
                    var medals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                                 ?? new List<EventsDTO.EventVersusTeams>();

                    foreach (var medal in medals)
                    {
                        // avoid double delete if API returns duplicates
                        if (!deletedIds.Add(medal.ID))
                            continue;

                        var ok = await apiService.DeleteAsync($"/Events/VersusTeams/{medal.ID}");
                        if (ok) deleted++;
                    }
                }

                if (deleted > 0)
                    Snackbar.Add($"Team medal deleted ({deleted} record(s)).", Severity.Success);
                else
                    Snackbar.Add("No team medals deleted.", Severity.Warning);

                _existingTeamMedals = new();
                _existingMedal = null;
                _selectedMedal = null;
                StateHasChanged();
                return;
            }

            // ✅ INDIVIDUAL delete (unchanged behavior)
            if (_existingMedal == null) return;

            var success = await apiService.DeleteAsync($"/Events/VersusTeams/{_existingMedal.ID}");

            if (success)
            {
                Snackbar.Add("Medal deleted successfully.", Severity.Success);
                _existingMedal = null;
                _selectedMedal = null;
                StateHasChanged();
            }
            else
            {
                Snackbar.Add("Failed to delete medal.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting medal: {ex.Message}", Severity.Error);
        }
    }

    // ================================
    // ✅ Linked Team Championship medal DELETE (mirrors SaveLinkedTeamChampionshipMedal)
    // ================================
    private async Task DeleteLinkedTeamChampionshipMedal()
    {
        if (!_selectedSubcategoryId.HasValue)
        {
            Snackbar.Add("Select a category first.", Severity.Warning);
            return;
        }

        if (LinkedPerformanceIDs == null || !LinkedPerformanceIDs.Any())
        {
            Snackbar.Add("No linked performances found. (LinkedPerformanceIDs is empty)", Severity.Warning);
            return;
        }

        int deletedTotal = 0;

        foreach (var perfId in LinkedPerformanceIDs.Distinct())
        {
            var scoreIds = await GetScoreIdsForRegion_Subcategory(perfId, RegionID, _selectedSubcategoryId.Value);
            if (scoreIds == null || !scoreIds.Any())
                continue;

            deletedTotal += await DeleteMedalsByScoreIds(perfId, scoreIds, TeamID);
        }

        if (deletedTotal > 0)
            Snackbar.Add($"Medal deleted ({deletedTotal} record(s)).", Severity.Success);
        else
            Snackbar.Add("No medals deleted in linked performances.", Severity.Warning);
    }

    private async Task<int> DeleteMedalsByScoreIds(int performanceId, List<int> scoreIds, int? teamId)
    {
        if (scoreIds == null || scoreIds.Count == 0)
            return 0;

        // Load existing medals for this performance once
        string loadUrl = $"/Events/VersusTeams?performanceID={performanceId}";
        var existingMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                             ?? new List<EventsDTO.EventVersusTeams>();

        int deleted = 0;
        var seen = new HashSet<int>();

        foreach (var scoreId in scoreIds.Distinct())
        {
            // ✅ Match by scoreId AND teamId to avoid collisions
            var matches = existingMedals.Where(m =>
                m.PerformanceScoreID == scoreId &&
                m.TeamID == teamId)
                .ToList();

            foreach (var medal in matches)
            {
                if (!seen.Add(medal.ID))
                    continue;

                var ok = await apiService.DeleteAsync($"/Events/VersusTeams/{medal.ID}");
                if (ok) deleted++;
            }
        }

        return deleted;
    }


    private bool ShouldShowMedalTally()
    {
        // Ensure we have necessary data
        if (_selectedEvent == null || !_selectedSubcategoryId.HasValue)
            return false;

        // Find the subcategory
        var subcategory = _sportSubcategories?.FirstOrDefault(sc => sc.ID == _selectedSubcategoryId.Value) ??
                          _filteredSubcategories?.FirstOrDefault(sc => sc.ID == _selectedSubcategoryId.Value);

        if (subcategory == null || string.IsNullOrEmpty(subcategory.Subcategory))
            return false;

        string subcategoryName = subcategory.Subcategory;

        // Check if the subcategory contains "Team Championship" or "Individual All-Around"
        bool isSpecialCategory = subcategoryName.Contains("Team Championship", StringComparison.OrdinalIgnoreCase) ||
                                 subcategoryName.Contains("Individual All-Around", StringComparison.OrdinalIgnoreCase);

        bool isEliminationStage = _eventStageId == 1; // Assuming 1 is Elimination Rounds stage ID
        bool isFinalsStage = _eventStageId == 4; // Assuming 4 is Finals stage ID

        if (IsAerobicGymnasticsSelected() && isFinalsStage)
            return true;

        // For subcategories containing Team Championship or Individual All-Around: show during Elimination Rounds
        if (isSpecialCategory)
        {
            return isEliminationStage;
        }

        // For other subcategories: show only during Finals
        return isFinalsStage;
    }

    // ================================
    // ✅ MEDAL PROPAGATION HELPERS
    // ================================

    private async Task<List<int>> GetScoreIdsForRegion_Subcategory(int performanceId, int regionId, int subcategoryId)
    {
        // 1) Load participants for this performance
        string teamUrl = $"/PerformanceBased/OpposingTeams/{performanceId}";
        var perfTeams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(teamUrl)
                        ?? new List<PerformanceBasedDTO.PerformanceTeam>();

        var regionPerfTeamIds = perfTeams
            .Where(t => t.RegionID == regionId)
            .Select(t => t.ID) // PerformanceTeamID
            .Distinct()
            .ToList();

        if (!regionPerfTeamIds.Any())
            return new List<int>();

        // 2) Load scores for this performance
        string scoresUrl = $"/PerformanceScore/Score/{performanceId}";
        var scores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(scoresUrl)
                     ?? new List<PerformanceBasedDTO.PerformanceScore>();

        // 3) Return score IDs for those region participants + chosen subcategory
        return scores
            .Where(s => s.SportSubcategoryID == subcategoryId &&
                        regionPerfTeamIds.Contains(s.PerformanceTeamID))
            .Select(s => s.ID)
            .Distinct()
            .ToList();
    }

    private async Task UpsertMedalByScoreIds(
     int performanceId,
     int regionId,
     List<int> scoreIds,
     string medalRank,
     int? teamId // ✅ added
 )
    {
        if (scoreIds == null || scoreIds.Count == 0)
            return;

        // Load existing medals for this performance once
        string loadUrl = $"/Events/VersusTeams?performanceID={performanceId}";
        var existingMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                             ?? new List<EventsDTO.EventVersusTeams>();

        int success = 0;

        foreach (var scoreId in scoreIds.Distinct())
        {
            // ✅ IMPORTANT: match by scoreId AND teamId to avoid collisions
            var existing = existingMedals.FirstOrDefault(m =>
                m.PerformanceScoreID == scoreId &&
                m.TeamID == teamId);

            var payload = new EventsDTO.EventVersusTeams
            {
                PerformanceID = performanceId,
                PerformanceScoreID = scoreId,
                SchoolRegionID = regionId,
                TeamID = teamId, // ✅ now saved
                Rank = medalRank,
                Score = null,
                RecentUpdateAt = DateTime.Now
            };

            if (existing != null)
            {
                payload.ID = existing.ID;
                var ok = await apiService.PutAsync<EventsDTO.EventVersusTeams>(
                    $"/Events/VersusTeams/{existing.ID}", payload);

                if (ok) success++;
            }
            else
            {
                var created = await apiService.PostAsync<EventsDTO.EventVersusTeams>(
                    "/Events/VersusTeams", payload);

                if (created != null) success++;
            }
        }

        if (success > 0)
            Snackbar.Add($"Medal saved ({success} record(s)).", Severity.Success);
    }


    private async Task SaveLinkedTeamChampionshipMedal()
    {
        if (!_selectedSubcategoryId.HasValue)
        {
            Snackbar.Add("Select a category first.", Severity.Warning);
            return;
        }

        if (string.IsNullOrWhiteSpace(_selectedMedal))
        {
            Snackbar.Add("Select a medal first.", Severity.Warning);
            return;
        }

        if (LinkedPerformanceIDs == null || !LinkedPerformanceIDs.Any())
        {
            Snackbar.Add("No linked performances found. (LinkedPerformanceIDs is empty)", Severity.Warning);
            return;
        }

        int totalScoresFound = 0;

        foreach (var perfId in LinkedPerformanceIDs.Distinct())
        {
            var scoreIds = await GetScoreIdsForRegion_Subcategory(perfId, RegionID, _selectedSubcategoryId.Value);
            totalScoresFound += scoreIds.Count;

            if (scoreIds.Any())
                await UpsertMedalByScoreIds(perfId, RegionID, scoreIds, _selectedMedal!, TeamID);
        }

        if (totalScoresFound == 0)
            Snackbar.Add("No score rows found in linked performances. Save the score first.", Severity.Warning);
    }

    private bool IsAerobicGymnasticsSelected()
    {
        var sportName =
            _selectedEvent?.MainCategory;

        return !string.IsNullOrWhiteSpace(sportName)
               && sportName.Contains("Aerobic Gymnastics", StringComparison.OrdinalIgnoreCase);
    }

    private async Task ApplyForcedCategoryIfAny()
    {
        if (string.IsNullOrWhiteSpace(ForcedCategoryName))
            return;

        // make sure subcategories are already loaded
        if (_sportSubcategories == null || !_sportSubcategories.Any())
            return;

        var match = _sportSubcategories.FirstOrDefault(sc =>
            !string.IsNullOrWhiteSpace(sc.Subcategory) &&
            sc.Subcategory.Contains(ForcedCategoryName, StringComparison.OrdinalIgnoreCase));

        if (match == null)
        {
            Snackbar.Add($"Category '{ForcedCategoryName}' not found for this event.", Severity.Warning);
            return;
        }

        _selectedSubcategoryId = match.ID;
        _isSubcategoryLocked = true;

        // load existing if any
        if (_opposingTeamId.HasValue)
            await LoadExistingScore();

        StateHasChanged();
    }

    //COMBINED EVENT

    [Parameter] public int? CombinedEventID { get; set; }
    [Parameter] public List<int> CombinedPerformanceIDs { get; set; } = new();

    private List<int> GetPerformanceIdsToSave()
    {
        if (!EventID.HasValue)
            return new List<int>();

        // Default behavior: save only to the opened EventID
        var result = new List<int> { EventID.Value };

        // Only for team save do we expand to combined IDs
        if (!IsTeamEvent || !TeamID.HasValue)
            return result;

        // ✅ If parent explicitly passed the IDs, trust it (best)
        if (CombinedPerformanceIDs != null && CombinedPerformanceIDs.Any())
            return CombinedPerformanceIDs.Distinct().ToList();

        // ✅ Else try derive using CombinedEventID (same behavior as before)
        if (CombinedEventID.HasValue && _allOpposingTeams != null && _allOpposingTeams.Any())
        {
            var ids = _allOpposingTeams
                .Where(t => t.RegionID == RegionID
                         && t.TeamID == TeamID
                         && t.CombinedEventID == CombinedEventID.Value)
                .Select(t => t.PerformanceID)
                .Distinct()
                .ToList();

            if (ids.Any())
                return ids;
        }

        return result;
    }

    private const int TeamChampionshipMinTeamId = 8_000_000;  // adjust to your real rule
    private const int AerobicDanceMaxTeamId = 800_000;    // adjust to your real rule

    private static bool IsTeamChampionshipTeam(int? teamId)
        => teamId.HasValue && teamId.Value >= TeamChampionshipMinTeamId;

    private static bool IsAerobicDanceTeam(int? teamId)
        => teamId.HasValue && teamId.Value > 0 && teamId.Value <= AerobicDanceMaxTeamId;

    private async Task AutoSelectSubcategory()
    {
        if (_selectedEvent == null || !_sportSubcategories.Any())
            return;

        // Only relevant for Aerobic Gymnastics main category
        if (string.IsNullOrWhiteSpace(_selectedMainCategory) ||
            !_selectedMainCategory.Contains("Aerobic Gymnastics", StringComparison.OrdinalIgnoreCase))
            return;

        // First filter subcategories to only show relevant ones
        await FilterSubcategoriesByMainCategory();

        // =========================================================
        // ✅ 1) FORCE Aerobic Dance based on TeamID bucket (best)
        // =========================================================
        if (IsTeamEvent && TeamID.HasValue)
        {
            // If it's NOT team championship, treat it as aerobic dance team
            // (or use IsAerobicDanceTeam(TeamID) if you have a strict range)
            bool shouldForceAerobicDance =
                IsAerobicDanceTeam(TeamID) || !IsTeamChampionshipTeam(TeamID);

            if (shouldForceAerobicDance)
            {
                var dance = _sportSubcategories.FirstOrDefault(sc =>
                    !string.IsNullOrWhiteSpace(sc.Subcategory) &&
                    sc.Subcategory.Contains("Aerobic Dance", StringComparison.OrdinalIgnoreCase));

                if (dance != null)
                {
                    _selectedSubcategoryId = dance.ID;
                    await LoadExistingScore();
                    StateHasChanged();
                }

                return; // ✅ stop here, do NOT let playerCount override it
            }
        }

        // =========================================================
        // ✅ 2) Otherwise fallback to player-count logic (original)
        // =========================================================
        var playerCount = GetPlayerCountPerRegion(_selectedEvent);

        if (!playerCount.HasValue)
            return;

        string? targetSubcategoryName = playerCount.Value switch
        {
            2 => "(Aero) Mixed Pair",
            3 => "(Aero) Trio",
            >= 5 and <= 8 => "(Aero) Aerobic Dance",
            _ => null
        };

        if (string.IsNullOrWhiteSpace(targetSubcategoryName))
            return;

        // Try normal matching
        var targetSubcategory = _sportSubcategories.FirstOrDefault(sc =>
            sc.Subcategory?.Contains(targetSubcategoryName, StringComparison.OrdinalIgnoreCase) == true);

        // Fuzzy fallback
        if (targetSubcategory == null)
        {
            var fuzzy = targetSubcategoryName
                .Replace("(Aero)", "", StringComparison.OrdinalIgnoreCase)
                .Trim();

            targetSubcategory = _sportSubcategories.FirstOrDefault(sc =>
                sc.Subcategory?.Contains(fuzzy, StringComparison.OrdinalIgnoreCase) == true);
        }

        if (targetSubcategory != null)
        {
            _selectedSubcategoryId = targetSubcategory.ID;
            await LoadExistingScore();
            StateHasChanged();
        }
    }


    // Data models
    public class PerformanceBasedDTO
    {
        public class PerformanceEvent
        {
            public int ID { get; set; }
            public int? SportID { get; set; }
            public string MainCategory { get; set; }
            public int? LevelID { get; set; }
            public int? GenderID { get; set; }
            public int StageID { get; set; }
        }

        public class PerformanceTeam
        {
            public int ID { get; set; }
            public int PerformanceID { get; set; }
            public int? TeamID { get; set; }
            public int RegionID { get; set; }
            public string PlayerID { get; set; }
            public int? CombinedEventID { get; set; }
        }

        public class PerformanceScore
        {
            public int ID { get; set; }
            public int PerformanceID { get; set; }
            public int PerformanceTeamID { get; set; }
            public int SportSubcategoryID { get; set; }
            public decimal Score { get; set; }
            public int Rank { get; set; }
            public string? UserID { get; set; }
            public DateTime UpdatedAt { get; set; }
            public int? TeamID { get; set; }
        }
    }

    public class SportsDTO
    {
        public class SportSubcategories
        {
            public int ID { get; set; }
            public string? Subcategory { get; set; }
            public int? SportID { get; set; }
            public int? SportGenderCategoryID { get; set; }
            public int? SchoolLevelID { get; set; }
            public string? MainCategory { get; set; }
        }

        public class SportGenderCategories
        {
            public int ID { get; set; }
            public string? Gender { get; set; }
        }
    }

    public class SchoolsDTO
    {
        public class SchoolRegions
        {
            public int ID { get; set; }
            public string? Region { get; set; }
            public string? Abbreviation { get; set; }
        }

        public class SchoolLevels
        {
            public int ID { get; set; }
            public string? Level { get; set; }
        }
    }

    public class ProfilePlayersDTO
    {
        public class Players
        {
            public string ID { get; set; } = string.Empty;
            public string? FirstName { get; set; }
            public string? LastName { get; set; }
        }
    }

    public class EventsDTO
    {
        public class EventVersusTeams
        {
            public int ID { get; set; }
            public string? EventID { get; set; }
            public int? PerformanceScoreID { get; set; }
            public int? PerformanceID { get; set; }
            public int? TeamID { get; set; }
            public int? SchoolRegionID { get; set; }
            public string? Score { get; set; }
            public string? Rank { get; set; }
            public DateTime? RecentUpdateAt { get; set; }
        }
    }
}