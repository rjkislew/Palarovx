@using Microsoft.AspNetCore.Components

@inject ISnackbar Snackbar
@inject APIService apiService
@inject IDialogService DialogService
@inject CookieService cookieService


@if (_isLoaded == true)
{
    <MudDialog>
        <DialogContent>
            <MudGrid Spacing="5">
                <!-- Player Info -->
                <MudItem xs="12" Class="mb-3">
                    @if (IsTeamEvent)
                    {
                        <MudText Typo="Typo.h6"> @_regionName</MudText>
                    }
                    else
                    {
                        <MudText Typo="Typo.h6" Class="mb-2">@_playerName</MudText>
                        <MudText Typo="Typo.caption">Region: @_regionName</MudText>
                    }
                    <MudDivider Class="my-2"/>
                </MudItem>

                <!-- Sport Details -->
                <MudItem xs="12" Class="mb-3">
                    <MudStack Spacing="1">
                        <MudGrid Spacing="1">
                            <MudItem xs="12">
                                <MudSelect @bind-Value="_selectedMainCategory" Margin="Margin.Dense"
                                           Label="Event" T="string"
                                           ShrinkLabel Variant="Variant.Outlined" Clearable
                                           ReadOnly="true">
                                    @if (!string.IsNullOrEmpty(_selectedMainCategory))
                                    {
                                        <MudSelectItem
                                            Value="@_selectedMainCategory">@_selectedMainCategory</MudSelectItem>
                                    }
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12">
                                <MudSelect Value="@_selectedSubcategoryId"
                                           ValueChanged="@((int? value) => OnSubcategoryChanged(value))"
                                           Margin="Margin.Dense"
                                           Label="Category" T="int?"
                                           ShrinkLabel Variant="Variant.Outlined" Clearable>
                                    <MudVirtualize Items="_sportSubcategories" Context="subCategory">
                                        <MudSelectItem T="int?"
                                                       Value="@subCategory.ID">@subCategory.Subcategory</MudSelectItem>
                                    </MudVirtualize>
                                </MudSelect>
                            </MudItem>

                            <MudItem xs="12">
                                <MudNumericField @bind-Value="_scoreValue"
                                                 HideSpinButtons="true"
                                                 Label="Score"
                                                 Variant="Variant.Outlined"
                                                 Min="0"
                                                 Max="1000"
                                                 Step="0.1"
                                                 Margin="Margin.Dense"
                                                 Disabled="@_isScoreInputDisabled" />
                            </MudItem>
                        </MudGrid>
                    </MudStack>
                </MudItem>

                @if (_existingScoreId.HasValue && _selectedSubcategoryId.HasValue)
                {
                    @if (ShouldShowMedalTally())
                    {
                        <MudItem xs="12" Class="mb-3">
                            <MudStack Spacing="1">
                                <MudText>Medal Tally</MudText>
                                <MudDivider />
                                <MudGrid Spacing="1" Class="mt-2">
                                    <MudItem xs="12">
                                        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                            <MudItem xs="12" sm="10">
                                                <MudSelect @bind-Value="_selectedMedal"
                                                Label="Select Medal"
                                                ShrinkLabel
                                                Clearable
                                                T="string"
                                                Variant="Variant.Outlined"
                                                Margin="Margin.Dense" FullWidth="true">
                                                    <MudSelectItem Value="@("Gold")">Gold</MudSelectItem>
                                                    <MudSelectItem Value="@("Silver")">Silver</MudSelectItem>
                                                    <MudSelectItem Value="@("Bronze")">Bronze</MudSelectItem>
                                                </MudSelect>
                                            </MudItem>

                                            <MudItem xs="12" sm="2">
                                                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                                    <MudIconButton Icon="@Icons.Material.Filled.Check" Variant="Variant.Filled"
                                                    Color="Color.Success"
                                                    OnClick="SaveMedal"
                                                    Disabled="@(string.IsNullOrEmpty(_selectedMedal) && _existingMedal == null)" />

                                                    @if (_existingMedal != null && !string.IsNullOrEmpty(_existingMedal.Rank))
                                                    {
                                                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Variant="Variant.Filled"
                                                        Color="Color.Error"
                                                        OnClick="DeleteMedal" />
                                                    }
                                                </MudStack>
                                            </MudItem>
                                        </MudStack>
                                    </MudItem>
                                </MudGrid>
                            </MudStack>
                        </MudItem>
                    }
                }

            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudButton Variant="Variant.Text" OnClick="ConfirmSaveScore">Save</MudButton>
        </DialogActions>
    </MudDialog>
}

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; }

    [Parameter] public int RegionID { get; set; }
    [Parameter] public string PlayerID { get; set; } = string.Empty;
    [Parameter] public int? EventID { get; set; }
    [Parameter] public EventCallback OnScoreSaved { get; set; }

    [Parameter] public bool IsTeamEvent { get; set; } = false;
    [Parameter] public List<string> TeamPlayerIDs { get; set; } = new();
    [Parameter] public int? TeamID { get; set; }

    private string _playerName = "Loading...";
    private string _regionName = "Loading...";
    private double _scoreValue;
    private string? _selectedMainCategory;
    private int? _selectedSubcategoryId;
    private bool _isLoaded = false;
    private int? _existingScoreId;

    private bool _isScoreInputDisabled = false; // Add this flag
    private int? _eliminationRank; // Add this to store current rank
    private int _eventStageId = 0;

    private List<string> _mainCategories = new();
    private PerformanceBasedDTO.PerformanceEvent? _selectedEvent;
    private List<SportsDTO.SportSubcategories> _sportSubcategories = new();
    private List<SportsDTO.SportSubcategories> _filteredSubcategories = new();
    private int? _opposingTeamId;
    private string _currentUserId = string.Empty;

    private List<PerformanceBasedDTO.PerformanceTeam> _allOpposingTeams = new();
    private List<string> _teamPlayerNames = new();

    private List<SportsDTO.SportGenderCategories> _sportGenderCategories = new();
    private List<SchoolsDTO.SchoolLevels> _schoolLevels = new();
    private int? _selectedSportIDValue;

    private Dictionary<string, int> _teamPerformanceTeamIds = new(); // PlayerID -> PerformanceTeamID
    private List<int> _existingTeamScoreIds = new();                 // score IDs for this team+subcategory
    private Dictionary<int, PerformanceBasedDTO.PerformanceScore> _existingTeamScoresByPerfTeamId = new(); // perfTeamId -> score row

    protected override async Task OnInitializedAsync()
    {
        await LoadInitialData();
        _isLoaded = true;
    }

    private async Task LoadInitialData()
    {
        try
        {
            await GetCurrentUserIdAsync();
            await LoadAllOpposingTeams();
            await LoadEventData();
            await LoadPlayerAndRegionData();
            await LoadSportData(); 
            await LoadOpposingTeam();
            await AutoSelectSubcategory();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading data: {ex.Message}", Severity.Error);
        }
    }

    private async Task<string> GetCurrentUserIdAsync()
    {
        try
        {
            // Try to get user ID from cookie first
            var userId = await cookieService.GetCookie("userID");

            if (!string.IsNullOrEmpty(userId))
            {
                return userId;
            }

            // If no user ID in cookie, check for token
            var token = await cookieService.GetCookie("authenticationToken");
            if (string.IsNullOrEmpty(token))
            {
                Snackbar.Add("User not authenticated. Please log in.", Severity.Error);
                return string.Empty;
            }

            Snackbar.Add("Unable to retrieve user ID. Please log in again.", Severity.Warning);
            return string.Empty;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error getting user ID: {ex.Message}", Severity.Error);
            return string.Empty;
        }
    }

    private async Task LoadEventData()
    {
        try
        {
            if (!EventID.HasValue)
            {
                Snackbar.Add("No event ID provided", Severity.Error);
                return;
            }

            string eventUrl = $"/PerformanceBased/PerformanceEvent/{EventID.Value}";
            _selectedEvent = await apiService.GetSingleAsync<PerformanceBasedDTO.PerformanceEvent>(eventUrl);

            if (_selectedEvent == null)
            {
                var eventList = await apiService.GetAsync<PerformanceBasedDTO.PerformanceEvent>(eventUrl);
                _selectedEvent = eventList?.FirstOrDefault();
            }

            if (_selectedEvent != null)
            {
                _selectedMainCategory = _selectedEvent.MainCategory;
                _selectedSportIDValue = _selectedEvent.SportID;
                _eventStageId = _selectedEvent.StageID;

                // Load the necessary data for filtering
                await GetGenderCategoriesAsync();
                await GetSchoolLevelsAsync();

                // Now filter subcategories using the event data
                await FilterSubcategoriesByEvent();
            }
            else
            {
                Snackbar.Add($"Event not found for ID: {EventID.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading event data: {ex.Message}", Severity.Error);
        }
    }

    private async Task FilterSubcategoriesByEvent()
    {
        if (_selectedEvent == null) return;

        try
        {
            // Use the specific filtering method with event data
            await GetSportSubCategoriesAsync();

            if (!string.IsNullOrEmpty(_selectedMainCategory))
            {
                await FilterSubcategoriesByMainCategory();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error filtering subcategories: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadPlayerAndRegionData()
    {
        if (IsTeamEvent && TeamPlayerIDs.Any())
        {
            await LoadTeamPlayerNames();
        }
        else if (!string.IsNullOrEmpty(PlayerID) && EventID != null)
        {
            try
            {
                string playerUrl = $"/Profiles/Player?id={PlayerID}";
                var playerResult = await apiService.GetAsync<ProfilePlayersDTO.Players>(playerUrl);
                var player = playerResult?.FirstOrDefault();

                if (player != null)
                {
                    _playerName = $"{player.FirstName} {player.LastName}";
                }
                else
                {
                    _playerName = "Player not found";
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error loading player data: {ex.Message}", Severity.Error);
            }
        }

        try
        {
            string regionUrl = $"/Schools/Regions?id={RegionID}";
            var regionResult = await apiService.GetAsync<SchoolsDTO.SchoolRegions>(regionUrl);
            var region = regionResult?.FirstOrDefault();

            if (region != null)
            {
                _regionName = region.Abbreviation ?? region.Region;
            }
            else
            {
                _regionName = "Region not found";
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading region data: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadTeamPlayerNames()
    {
        _teamPlayerNames = new List<string>();

        foreach (var playerId in TeamPlayerIDs)
        {
            try
            {
                string playerUrl = $"/Profiles/Player?id={playerId}";
                var playerResult = await apiService.GetAsync<ProfilePlayersDTO.Players>(playerUrl);
                var player = playerResult?.FirstOrDefault();

                if (player != null)
                {
                    _teamPlayerNames.Add($"{player.FirstName} {player.LastName}");
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error loading team player {playerId}: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task LoadOpposingTeam()
    {
        if (EventID == null) return;

        try
        {
            string url = $"/PerformanceBased/OpposingTeams/{EventID}";
            var teams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(url)
                       ?? new List<PerformanceBasedDTO.PerformanceTeam>();

            if (IsTeamEvent)
            {
                List<PerformanceBasedDTO.PerformanceTeam> members = new();

                // 1) Prefer TeamID (ideal)
                if (TeamID.HasValue)
                {
                    members = teams
                        .Where(t => t.RegionID == RegionID
                                 && t.TeamID == TeamID
                                 && t.PerformanceID == EventID)
                        .ToList();
                }

                // 2) Fallback using TeamPlayerIDs
                if (!members.Any() && TeamPlayerIDs != null && TeamPlayerIDs.Any())
                {
                    members = teams
                        .Where(t => t.PerformanceID == EventID
                                 && t.RegionID == RegionID
                                 && TeamPlayerIDs.Contains(t.PlayerID))
                        .ToList();

                    if (!TeamID.HasValue && members.Any())
                        TeamID = members.First().TeamID;
                }

                if (!members.Any())
                {
                    Snackbar.Add("Could not find team members for this event/region.", Severity.Warning);
                    return;
                }

                // ✅ Build lookup needed by SaveScore Team logic
                _teamPerformanceTeamIds = members
                    .Where(m => !string.IsNullOrWhiteSpace(m.PlayerID))
                    .GroupBy(m => m.PlayerID)
                    .ToDictionary(g => g.Key, g => g.First().ID);

                // Keep one representative opposingTeamId (some parts still use it)
                _opposingTeamId = members.First().ID;
                return;
            }

            // ✅ Individual
            var team = teams.FirstOrDefault(t =>
                t.RegionID == RegionID &&
                t.PlayerID == PlayerID &&
                t.PerformanceID == EventID);

            if (team != null)
            {
                _opposingTeamId = team.ID;
                TeamID = team.TeamID; // might still be null
            }
            else
            {
                Snackbar.Add("Could not find team information", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading team data: {ex.Message}", Severity.Error);
        }
    }


    private async Task LoadSportData()
    {
        try
        {
            // If we haven't loaded specific subcategories yet, load all as fallback
            if (!_sportSubcategories.Any())
            {
                string subcategoriesUrl = "/Sports/Subcategories";
                _sportSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(subcategoriesUrl)
                                      ?? new List<SportsDTO.SportSubcategories>();
            }

            LoadMainCategories();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading sport data: {ex.Message}", Severity.Error);
        }
    }

    private void LoadMainCategories()
    {
        _mainCategories = _sportSubcategories
            .Where(sc => !string.IsNullOrEmpty(sc.MainCategory))
            .Select(sc => sc.MainCategory!)
            .Distinct()
            .ToList();
    }

    private async Task LoadExistingScore()
    {
        if (EventID == null || !_selectedSubcategoryId.HasValue) return;

        try
        {
            string url = $"/PerformanceScore/Score/{EventID}";
            var scores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(url)
                        ?? new List<PerformanceBasedDTO.PerformanceScore>();

            _existingTeamScoreIds = new();
            _existingTeamScoresByPerfTeamId = new();

            if (IsTeamEvent && TeamID.HasValue)
            {
                // ✅ Get ALL score rows for this Team + Subcategory
                var teamScores = scores
                    .Where(s => s.TeamID == TeamID
                             && s.SportSubcategoryID == _selectedSubcategoryId.Value)
                    .ToList();

                if (!teamScores.Any())
                {
                    _existingScoreId = null;
                    _scoreValue = 0;
                    _existingMedal = null;
                    _selectedMedal = null;
                    await CheckEliminationRankAndPermission();
                    StateHasChanged();
                    return;
                }

                _existingTeamScoreIds = teamScores.Select(s => s.ID).ToList();
                _existingTeamScoresByPerfTeamId = teamScores.ToDictionary(s => s.PerformanceTeamID, s => s);

                // ✅ Use one representative value for UI
                _existingScoreId = teamScores.First().ID;
                _scoreValue = (double)teamScores.First().Score;

                await LoadExistingMedal(); // if you will also implement team-medal later
                await CheckEliminationRankAndPermission();
                StateHasChanged();
                return;
            }

            // ✅ Individual
            var existingScore = scores.FirstOrDefault(s =>
                s.PerformanceTeamID == _opposingTeamId &&
                s.SportSubcategoryID == _selectedSubcategoryId.Value &&
                !s.TeamID.HasValue);

            if (existingScore != null)
            {
                _existingScoreId = existingScore.ID;
                _scoreValue = (double)existingScore.Score;
                await LoadExistingMedal();
            }
            else
            {
                _existingScoreId = null;
                _scoreValue = 0;
                _existingMedal = null;
                _selectedMedal = null;
            }

            await CheckEliminationRankAndPermission();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading existing score: {ex.Message}", Severity.Error);
            _existingScoreId = null;
            _scoreValue = 0;
            _existingMedal = null;
            _selectedMedal = null;
            _existingTeamScoreIds = new();
            _existingTeamScoresByPerfTeamId = new();
            StateHasChanged();
        }
    }


    private async Task CheckEliminationRankAndPermission()
    {
        if (_eventStageId != 4)
        {
            _isScoreInputDisabled = false;
            _eliminationRank = null;
            return;
        }

        try
        {
            if (_selectedEvent == null) return;

            int? eliminationEventId = await GetEliminationStageEventId();

            if (!eliminationEventId.HasValue)
            {
                _isScoreInputDisabled = false;
                _eliminationRank = null;
                return;
            }

            _eliminationRank = await GetPlayerEliminationRank(eliminationEventId.Value);

            if (_eliminationRank.HasValue && _eliminationRank.Value >= 9)
            {
                _isScoreInputDisabled = true;
            }
            else
            {

                _isScoreInputDisabled = false;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error checking elimination rank: {ex.Message}", Severity.Error);
            _isScoreInputDisabled = false;
            _eliminationRank = null;
        }
    }

    private async Task<int?> GetEliminationStageEventId()
    {
        try
        {
            if (_selectedEvent == null) return null;

            var parameters = new List<string>();

            if (_selectedEvent.SportID.HasValue)
                parameters.Add($"sportID={_selectedEvent.SportID}");

            if (!string.IsNullOrEmpty(_selectedMainCategory))
                parameters.Add($"mainCategory={Uri.EscapeDataString(_selectedMainCategory)}");

            if (_selectedEvent.LevelID.HasValue)
                parameters.Add($"schoolLevelID={_selectedEvent.LevelID}");

            if (_selectedEvent.GenderID.HasValue)
                parameters.Add($"genderID={_selectedEvent.GenderID}");

            parameters.Add($"stageID=1");

            string url = "/PerformanceBased/PerformanceEvents";
            if (parameters.Any())
                url += "?" + string.Join("&", parameters);

            var eliminationEvents = await apiService.GetAsync<PerformanceBasedDTO.PerformanceEvent>(url);

            return eliminationEvents?.FirstOrDefault()?.ID;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error finding elimination stage: {ex.Message}", Severity.Warning);
            return null;
        }
    }

    private async Task<int?> GetPlayerEliminationRank(int eliminationEventId)
    {
        try
        {
            string teamUrl = $"/PerformanceBased/OpposingTeams/{eliminationEventId}";
            var teams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(teamUrl);

            PerformanceBasedDTO.PerformanceTeam team;

            if (IsTeamEvent && TeamID.HasValue)
            {
                team = teams?.FirstOrDefault(t =>
                    t.RegionID == RegionID &&
                    t.TeamID == TeamID &&
                    t.PerformanceID == eliminationEventId);
            }
            else
            {
                team = teams?.FirstOrDefault(t =>
                    t.RegionID == RegionID &&
                    t.PlayerID == PlayerID &&
                    t.PerformanceID == eliminationEventId);
            }

            if (team == null)
            {
                return null;
            }

            string scoresUrl = $"/PerformanceScore/Score/{eliminationEventId}";
            var scores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(scoresUrl)
                         ?? new List<PerformanceBasedDTO.PerformanceScore>();

            var eliminationScore = scores.FirstOrDefault(s =>
                s.PerformanceTeamID == team.ID &&
                s.SportSubcategoryID == _selectedSubcategoryId &&
                ((IsTeamEvent && s.TeamID.HasValue) || (!IsTeamEvent && !s.TeamID.HasValue)));

            return eliminationScore?.Rank;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error getting elimination rank: {ex.Message}", Severity.Warning);
            return null;
        }
    }

    private async Task OnSubcategoryChanged(int? newValue)
    {
        _selectedSubcategoryId = newValue;

        _scoreValue = 0;
        _existingScoreId = null;
        _existingMedal = null;
        _selectedMedal = null;

        if (_selectedSubcategoryId.HasValue && _opposingTeamId.HasValue)
        {
            await LoadExistingScore();
        }
        else
        {
            StateHasChanged(); // Ensure UI updates even if we don't load
        }
    }

    private async Task FilterSubcategoriesByMainCategory()
    {
        if (string.IsNullOrEmpty(_selectedMainCategory))
        {
            _filteredSubcategories = new List<SportsDTO.SportSubcategories>();
            return;
        }

        _filteredSubcategories = _sportSubcategories
            .Where(sc => sc.MainCategory == _selectedMainCategory)
            .ToList();

        StateHasChanged();
    }

    private async Task GetGenderCategoriesAsync()
    {
        try
        {
            string url = "/Sports/GenderCategories";
            _sportGenderCategories = await apiService.GetAsync<SportsDTO.SportGenderCategories>(url)
                                     ?? new List<SportsDTO.SportGenderCategories>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading gender categories: {ex.Message}", Severity.Error);
        }
    }

    private async Task GetSchoolLevelsAsync()
    {
        try
        {
            string url = "/Schools/Levels";
            _schoolLevels = await apiService.GetAsync<SchoolsDTO.SchoolLevels>(url)
                            ?? new List<SchoolsDTO.SchoolLevels>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading school levels: {ex.Message}", Severity.Error);
        }
    }

    private async Task GetSportSubCategoriesAsync()
    {
        if (_selectedEvent == null) return;

        try
        {
            var parameters = new List<string>();

            if (_selectedEvent.SportID.HasValue)
                parameters.Add($"sportID={_selectedEvent.SportID}");

            if (_selectedEvent.LevelID.HasValue)
                parameters.Add($"schoolLevelID={_selectedEvent.LevelID}");

            if (_selectedEvent.GenderID.HasValue)
                parameters.Add($"sportGenderCategoryID={_selectedEvent.GenderID}");

            if (!string.IsNullOrEmpty(_selectedMainCategory))
                parameters.Add($"mainCategory={Uri.EscapeDataString(_selectedMainCategory)}");

            string url = "/Sports/Subcategories";
            if (parameters.Any())
                url += "?" + string.Join("&", parameters);

            var filteredSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(url);

            if (filteredSubcategories != null && filteredSubcategories.Any())
            {
                _sportSubcategories = filteredSubcategories;
            }
            else
            {
                string fallbackUrl = "/Sports/Subcategories";
                _sportSubcategories = await apiService.GetAsync<SportsDTO.SportSubcategories>(fallbackUrl)
                                      ?? new List<SportsDTO.SportSubcategories>();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading sport subcategories: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadAllOpposingTeams()
    {
        if (!EventID.HasValue) return;

        try
        {
            string url = $"/PerformanceBased/OpposingTeams/{EventID}";
            _allOpposingTeams = await apiService.GetAsync<PerformanceBasedDTO.PerformanceTeam>(url)
                                ?? new List<PerformanceBasedDTO.PerformanceTeam>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading all opposing teams: {ex.Message}", Severity.Warning);
        }
    }

    private async Task AutoSelectSubcategory()
    {
        if (_selectedEvent == null || !_sportSubcategories.Any()) return;

        // First filter subcategories to only show relevant ones
        await FilterSubcategoriesByMainCategory();

        // Check if we can auto-select based on player count
        var playerCount = GetPlayerCountPerRegion(_selectedEvent);

        if (playerCount.HasValue)
        {
            string targetSubcategoryName = playerCount.Value switch
            {
                2 => "(Aero) Mixed Pair",
                3 => "(Aero) Trio",
                >= 5 and <= 8 => "(Aero) Aerobic Dance",
                _ => null
            };

            if (!string.IsNullOrEmpty(targetSubcategoryName))
            {
                var targetSubcategory = _sportSubcategories
                    .FirstOrDefault(sc =>
                        sc.Subcategory?.Contains(targetSubcategoryName) == true);

                if (targetSubcategory != null)
                {
                    _selectedSubcategoryId = targetSubcategory.ID;
                    await LoadExistingScore(); // Load existing score if any
                    StateHasChanged();
                }
                else
                {
                    // Try fuzzy matching
                    targetSubcategory = _sportSubcategories
                        .FirstOrDefault(sc =>
                            sc.Subcategory?.ToLower().Contains(targetSubcategoryName.ToLower().Replace("(aero) ", "")) == true);

                    if (targetSubcategory != null)
                    {
                        _selectedSubcategoryId = targetSubcategory.ID;
                        await LoadExistingScore();
                        StateHasChanged();
                    }
                }
            }
        }
    }

    private int? GetPlayerCountPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        if (_allOpposingTeams == null || evt?.ID == null) return null;

        // Group by RegionID and TeamID to get unique teams
        var teamGroups = _allOpposingTeams
            .Where(team => team.PerformanceID == evt.ID)
            .GroupBy(team => new { team.RegionID, team.TeamID })
            .ToList();

        if (!teamGroups.Any()) return null;

        // For individual events (no TeamID), count distinct players per region
        if (!IsTeamEvent)
        {
            var regionGroups = _allOpposingTeams
                .Where(team => team.PerformanceID == evt.ID)
                .GroupBy(team => team.RegionID)
                .ToList();

            return regionGroups.FirstOrDefault()?.Count() ?? 0;
        }

        // For team events, count players in each team and find the most common count
        var playerCounts = teamGroups
            .Select(group => group.Count())

            .Distinct()
            .ToList();

        // If all teams have the same player count, return that
        if (playerCounts.Count == 1)
        {
            return playerCounts.First();
        }

        // Otherwise, find the most frequent player count
        var mostFrequentCount = teamGroups
            .GroupBy(group => group.Count())
            .OrderByDescending(g => g.Count())
            .FirstOrDefault()?.Key;

        return mostFrequentCount;
    }

    private bool HasTwoPlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount == 2;
    }

    private bool HasThreePlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount == 3;
    }

    private bool HasFiveToEightPlayersPerRegion(PerformanceBasedDTO.PerformanceEvent evt)
    {
        var playerCount = GetPlayerCountPerRegion(evt);
        return playerCount >= 5 && playerCount <= 8;
    }

    private async Task ConfirmSaveScore()
    {
        if (!_selectedSubcategoryId.HasValue || _scoreValue <= 0 || !_opposingTeamId.HasValue)
        {
            Snackbar.Add("Please select a category and enter a valid score", Severity.Warning);
            return;
        }

        string action = _existingScoreId.HasValue ? "update" : "add";

        bool? result = await DialogService.ShowMessageBox(
            title: "Confirm Save Score",
            message: $"Are you sure you want to {action} this score?",
            yesText: "Yes",
            cancelText: "Cancel"
        );

        if (result == true)
        {
            await SaveScore();
        }
    }

    private async Task SaveScore()
    {
        try
        {
            if (!_selectedSubcategoryId.HasValue || _scoreValue <= 0)
            {
                Snackbar.Add("Please select a category and enter a valid score", Severity.Warning);
                return;
            }

            if (_isScoreInputDisabled)
            {
                Snackbar.Add("Scoring is disabled for this entry.", Severity.Warning);
                return;
            }

            var currentUserId = await GetCurrentUserIdAsync();

            // ✅ TEAM SCORE SAVE: upsert per member (per PerformanceTeamID)
            if (IsTeamEvent && TeamID.HasValue)
            {
                if (_teamPerformanceTeamIds == null || _teamPerformanceTeamIds.Count == 0)
                {
                    Snackbar.Add("Team members not loaded. Please reopen the dialog.", Severity.Error);
                    return;
                }

                // Load all scores once
                string getUrl = $"/PerformanceScore/Score/{EventID}";
                var allScores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(getUrl)
                               ?? new List<PerformanceBasedDTO.PerformanceScore>();

                int successCount = 0;

                foreach (var kvp in _teamPerformanceTeamIds)
                {
                    int perfTeamId = kvp.Value;

                    var existing = allScores.FirstOrDefault(s =>
                        s.PerformanceTeamID == perfTeamId &&
                        s.SportSubcategoryID == _selectedSubcategoryId.Value &&
                        s.TeamID == TeamID);

                    var scoreData = new PerformanceBasedDTO.PerformanceScore
                    {
                        PerformanceID = EventID.Value,
                        PerformanceTeamID = perfTeamId,
                        SportSubcategoryID = _selectedSubcategoryId.Value,
                        Score = (decimal)_scoreValue,
                        Rank = 0,
                        UserID = currentUserId,
                        UpdatedAt = DateTime.Now,
                        TeamID = TeamID
                    };

                    if (existing != null)
                    {
                        scoreData.ID = existing.ID;
                        var ok = await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                            $"/PerformanceScore/Score/{existing.ID}", scoreData);
                        if (ok) successCount++;
                    }
                    else
                    {
                        var created = await apiService.PostAsync<PerformanceBasedDTO.PerformanceScore>(
                            "/PerformanceScore/Score", scoreData);
                        if (created != null) successCount++;
                    }
                }

                if (successCount > 0)
                {
                    Snackbar.Add($"Team score saved for {successCount} player(s).", Severity.Success);

                    // IMPORTANT: rank calc must not treat team duplicates as separate teams
                    await CalculateAndUpdateRanks();

                    MudDialog.Close(DialogResult.Ok(true));
                }
                else
                {
                    Snackbar.Add("Failed to save team score.", Severity.Error);
                }

                return;
            }

            // ✅ INDIVIDUAL SCORE SAVE: original behavior (TeamID must be null)
            if (!_opposingTeamId.HasValue)
            {
                Snackbar.Add("Player team info not found.", Severity.Warning);
                return;
            }

            var individualScore = new PerformanceBasedDTO.PerformanceScore
            {
                PerformanceID = EventID.Value,
                PerformanceTeamID = _opposingTeamId.Value,
                SportSubcategoryID = _selectedSubcategoryId.Value,
                Score = (decimal)_scoreValue,
                Rank = 0,
                UserID = currentUserId,
                UpdatedAt = DateTime.Now,
                TeamID = null
            };

            bool success;

            if (_existingScoreId.HasValue)
            {
                individualScore.ID = _existingScoreId.Value;
                success = await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                    $"/PerformanceScore/Score/{_existingScoreId.Value}", individualScore);
            }
            else
            {
                var created = await apiService.PostAsync<PerformanceBasedDTO.PerformanceScore>(
                    "/PerformanceScore/Score", individualScore);
                success = created != null;
            }

            if (success)
            {
                Snackbar.Add("Score saved successfully!", Severity.Success);
                await CalculateAndUpdateRanks();
                MudDialog.Close(DialogResult.Ok(true));
            }
            else
            {
                Snackbar.Add("Failed to save score", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving score: {ex.Message}", Severity.Error);
        }
    }

    private async Task CalculateAndUpdateRanks()
    {
        if (!EventID.HasValue || !_selectedSubcategoryId.HasValue) return;

        try
        {
            string url = $"/PerformanceScore/Score/{EventID}";
            var allScores = await apiService.GetAsync<PerformanceBasedDTO.PerformanceScore>(url)
                            ?? new List<PerformanceBasedDTO.PerformanceScore>();

            // only current subcategory
            var scores = allScores
                .Where(s => s.SportSubcategoryID == _selectedSubcategoryId.Value)
                .ToList();

            if (!scores.Any()) return;

            // -------------------
            // 1) TEAM RANKING
            // -------------------
            var teamScores = scores.Where(s => s.TeamID.HasValue).ToList();
            if (teamScores.Any())
            {
                // representative score per team
                var teamRep = teamScores
                    .GroupBy(s => s.TeamID!.Value)
                    .Select(g => new
                    {
                        TeamID = g.Key,
                        Score = g.Max(x => x.Score) // or First().Score if always same
                    })
                    .OrderByDescending(x => x.Score)
                    .ToList();

                // dense ranking by score
                int rank = 1;
                decimal? prev = null;

                var teamRankMap = new Dictionary<int, int>();
                foreach (var t in teamRep)
                {
                    if (prev != null && t.Score != prev) rank++;
                    if (prev == null) rank = 1;

                    teamRankMap[t.TeamID] = rank;
                    prev = t.Score;
                }

                foreach (var row in teamScores)
                {
                    row.Rank = teamRankMap[row.TeamID!.Value];
                    await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                        $"/PerformanceScore/Score/{row.ID}", row);
                }
            }

            // -------------------
            // 2) INDIVIDUAL RANKING
            // -------------------
            var indivScores = scores.Where(s => !s.TeamID.HasValue).ToList();
            if (indivScores.Any())
            {
                var ordered = indivScores.OrderByDescending(s => s.Score).ToList();

                int rank = 1;
                decimal? prev = null;

                for (int i = 0; i < ordered.Count; i++)
                {
                    if (prev != null && ordered[i].Score != prev) rank = i + 1;
                    if (prev == null) rank = 1;

                    ordered[i].Rank = rank;
                    prev = ordered[i].Score;
                }

                foreach (var row in ordered)
                {
                    await apiService.PutAsync<PerformanceBasedDTO.PerformanceScore>(
                        $"/PerformanceScore/Score/{row.ID}", row);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error calculating ranks: {ex.Message}", Severity.Error);
        }
    }

    //MEDAL TALLY 

    private string? _selectedMedal;
    private EventsDTO.EventVersusTeams? _existingMedal;
    private List<EventsDTO.EventVersusTeams> _existingTeamMedals = new();


    private async Task LoadExistingMedal()
    {
        _existingMedal = null;
        _existingTeamMedals = new();
        _selectedMedal = null;

        try
        {
            // ✅ TEAM: load medal by TeamID + PerformanceID (recommended)
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                // BEST: have an endpoint that supports this query:
                // /Events/VersusTeams?performanceID=xx&teamID=yy
                string url = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
                var medals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(url)
                             ?? new List<EventsDTO.EventVersusTeams>();

                _existingTeamMedals = medals;

                // representative medal for UI
                var rep = medals.FirstOrDefault(m => !string.IsNullOrEmpty(m.Rank));
                _existingMedal = rep;
                _selectedMedal = rep?.Rank;

                StateHasChanged();
                return;
            }

            // ✅ INDIVIDUAL: existing logic (by PerformanceScoreID)
            if (!_existingScoreId.HasValue) return;

            string url2 = $"/Events/VersusTeams?performanceScoreID={_existingScoreId.Value}";
            var medals2 = await apiService.GetAsync<EventsDTO.EventVersusTeams>(url2);

            _existingMedal = medals2?.FirstOrDefault();
            _selectedMedal = _existingMedal?.Rank;

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading medal data: {ex.Message}", Severity.Error);
            _existingMedal = null;
            _existingTeamMedals = new();
            _selectedMedal = null;
        }
    }


    private async Task SaveMedal()
    {
        try
        {
            // If no medal selected => behave like delete
            if (string.IsNullOrEmpty(_selectedMedal))
            {
                // If something exists, delete it
                if ((IsTeamEvent && _existingTeamMedals.Any()) || (!IsTeamEvent && _existingMedal != null))
                {
                    await DeleteMedal();
                    return;
                }

                Snackbar.Add("Please select a medal or choose 'No Medal' to remove", Severity.Warning);
                return;
            }

            // ✅ TEAM
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                if (_existingTeamScoreIds == null || !_existingTeamScoreIds.Any())
                {
                    Snackbar.Add("No team score rows found. Save team score first.", Severity.Warning);
                    return;
                }

                // Load existing medals for this team (so we can update vs create)
                // (If your LoadExistingMedal already filled _existingTeamMedals, great; otherwise load it here too)
                if (_existingTeamMedals == null || !_existingTeamMedals.Any())
                {
                    string loadUrl = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
                    _existingTeamMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                                         ?? new List<EventsDTO.EventVersusTeams>();
                }

                int successCount = 0;

                foreach (var scoreId in _existingTeamScoreIds)
                {
                    // find existing medal row for this member score
                    var existing = _existingTeamMedals.FirstOrDefault(m => m.PerformanceScoreID == scoreId);

                    var medalTally = new EventsDTO.EventVersusTeams
                    {
                        // ✅ store these for grouping/queries
                        PerformanceID = EventID.Value,
                        TeamID = TeamID.Value,

                        // ✅ still store per score id (per player)
                        PerformanceScoreID = scoreId,

                        SchoolRegionID = RegionID,
                        Score = null,
                        Rank = _selectedMedal,
                        RecentUpdateAt = DateTime.Now
                    };

                    if (existing != null)
                    {
                        medalTally.ID = existing.ID;
                        var ok = await apiService.PutAsync<EventsDTO.EventVersusTeams>(
                            $"/Events/VersusTeams/{existing.ID}", medalTally);

                        if (ok) successCount++;
                    }
                    else
                    {
                        var created = await apiService.PostAsync<EventsDTO.EventVersusTeams>(
                            "/Events/VersusTeams", medalTally);

                        if (created != null) successCount++;
                    }
                }

                if (successCount > 0)
                {
                    Snackbar.Add($"Team medal saved for {successCount} player(s).", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to save team medal.", Severity.Error);
                }

                return;
            }

            // ✅ INDIVIDUAL
            if (!_existingScoreId.HasValue)
            {
                Snackbar.Add("No score exists to assign medal to", Severity.Warning);
                return;
            }

            var medalSingle = new EventsDTO.EventVersusTeams
            {
                PerformanceID = EventID,     // optional if you want always stored
                TeamID = null,              // individual

                PerformanceScoreID = _existingScoreId.Value,
                SchoolRegionID = RegionID,
                Score = null,
                Rank = _selectedMedal,
                RecentUpdateAt = DateTime.Now
            };

            if (_existingMedal != null)
            {
                medalSingle.ID = _existingMedal.ID;
                var ok = await apiService.PutAsync<EventsDTO.EventVersusTeams>(
                    $"/Events/VersusTeams/{_existingMedal.ID}", medalSingle);

                if (ok)
                {
                    Snackbar.Add("Medal updated successfully!", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to update medal", Severity.Error);
                }
            }
            else
            {
                var created = await apiService.PostAsync<EventsDTO.EventVersusTeams>(
                    "/Events/VersusTeams", medalSingle);

                if (created != null)
                {
                    Snackbar.Add("Medal assigned successfully!", Severity.Success);
                    await LoadExistingMedal();
                }
                else
                {
                    Snackbar.Add("Failed to assign medal", Severity.Error);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving medal: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteMedal()
    {
        bool? result = await DialogService.ShowMessageBox(
            title: "Confirm Delete Medal",
            message: "Are you sure you want to delete this medal?",
            yesText: "Yes",
            cancelText: "Cancel"
        );

        if (result != true) return;

        try
        {
            // ✅ TEAM delete: delete all medals for this team (either by loaded list, or fetch by performance+team)
            if (IsTeamEvent && TeamID.HasValue && EventID.HasValue)
            {
                if (_existingTeamMedals == null || !_existingTeamMedals.Any())
                {
                    string loadUrl = $"/Events/VersusTeams?performanceID={EventID.Value}&teamID={TeamID.Value}";
                    _existingTeamMedals = await apiService.GetAsync<EventsDTO.EventVersusTeams>(loadUrl)
                                         ?? new List<EventsDTO.EventVersusTeams>();
                }

                int deleted = 0;

                foreach (var medal in _existingTeamMedals)
                {
                    var ok = await apiService.DeleteAsync($"/Events/VersusTeams/{medal.ID}");
                    if (ok) deleted++;
                }

                if (deleted > 0)
                {
                    Snackbar.Add($"Team medal deleted ({deleted} record(s)).", Severity.Success);
                }
                else
                {
                    Snackbar.Add("No team medals deleted.", Severity.Warning);
                }

                _existingTeamMedals = new();
                _existingMedal = null;
                _selectedMedal = null;
                StateHasChanged();
                return;
            }

            // ✅ INDIVIDUAL delete
            if (_existingMedal == null) return;

            var success = await apiService.DeleteAsync($"/Events/VersusTeams/{_existingMedal.ID}");

            if (success)
            {
                Snackbar.Add("Medal deleted successfully.", Severity.Success);
                _existingMedal = null;
                _selectedMedal = null;
                StateHasChanged();
            }
            else
            {
                Snackbar.Add("Failed to delete medal.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting medal: {ex.Message}", Severity.Error);
        }
    }

    private bool ShouldShowMedalTally()
    {
        // Ensure we have necessary data
        if (_selectedEvent == null || !_selectedSubcategoryId.HasValue)
            return false;

        // Find the subcategory
        var subcategory = _sportSubcategories?.FirstOrDefault(sc => sc.ID == _selectedSubcategoryId.Value) ??
                          _filteredSubcategories?.FirstOrDefault(sc => sc.ID == _selectedSubcategoryId.Value);

        if (subcategory == null || string.IsNullOrEmpty(subcategory.Subcategory))
            return false;

        string subcategoryName = subcategory.Subcategory;

        // Check if the subcategory contains "Team Championship" or "Individual All-Around"
        bool isSpecialCategory = subcategoryName.Contains("Team Championship", StringComparison.OrdinalIgnoreCase) ||
                                 subcategoryName.Contains("Individual All-Around", StringComparison.OrdinalIgnoreCase);

        bool isEliminationStage = _eventStageId == 1; // Assuming 1 is Elimination Rounds stage ID
        bool isFinalsStage = _eventStageId == 4; // Assuming 4 is Finals stage ID

        if (IsAerobicGymnasticsSelected() && isFinalsStage)
        return true;

        // For subcategories containing Team Championship or Individual All-Around: show during Elimination Rounds
        if (isSpecialCategory)
        {
            return isEliminationStage;
        }

        // For other subcategories: show only during Finals
        return isFinalsStage;
    }

    private bool IsAerobicGymnasticsSelected()
    {
        var sportName =
            _selectedEvent?.MainCategory;

        return !string.IsNullOrWhiteSpace(sportName)
               && sportName.Contains("Aerobic Gymnastics", StringComparison.OrdinalIgnoreCase);
    }

    // Data models
    public class PerformanceBasedDTO
    {
        public class PerformanceEvent
        {
            public int ID { get; set; }
            public int? SportID { get; set; }
            public string MainCategory { get; set; }
            public int? LevelID { get; set; }
            public int? GenderID { get; set; }
            public int StageID { get; set; }
        }

        public class PerformanceTeam
        {
            public int ID { get; set; }
            public int PerformanceID { get; set; }
            public int? TeamID { get; set; }
            public int RegionID { get; set; }
            public string PlayerID { get; set; }
        }

        public class PerformanceScore
        {
            public int ID { get; set; }
            public int PerformanceID { get; set; }
            public int PerformanceTeamID { get; set; }
            public int SportSubcategoryID { get; set; }
            public decimal Score { get; set; }
            public int Rank { get; set; }
            public string? UserID { get; set; }
            public DateTime UpdatedAt { get; set; }
            public int? TeamID { get; set; }
        }
    }

    public class SportsDTO
    {
        public class SportSubcategories
        {
            public int ID { get; set; }
            public string? Subcategory { get; set; }
            public int? SportID { get; set; }
            public int? SportGenderCategoryID { get; set; }
            public int? SchoolLevelID { get; set; }
            public string? MainCategory { get; set; }
        }

        public class SportGenderCategories
        {
            public int ID { get; set; }
            public string? Gender { get; set; }
        }
    }

    public class SchoolsDTO
    {
        public class SchoolRegions
        {
            public int ID { get; set; }
            public string? Region { get; set; }
            public string? Abbreviation { get; set; }
        }

        public class SchoolLevels
        {
            public int ID { get; set; }
            public string? Level { get; set; }
        }
    }

    public class ProfilePlayersDTO
    {
        public class Players
        {
            public string ID { get; set; } = string.Empty;
            public string? FirstName { get; set; }
            public string? LastName { get; set; }
        }
    }

    public class EventsDTO
    {
        public class EventVersusTeams
        {
            public int ID { get; set; }
            public string? EventID { get; set; }
            public int? PerformanceScoreID { get; set; }
            public int? PerformanceID { get; set; }
            public int? TeamID { get; set; }
            public int? SchoolRegionID { get; set; }
            public string? Score { get; set; }
            public string? Rank { get; set; }
            public DateTime? RecentUpdateAt { get; set; }
        }
    }

}