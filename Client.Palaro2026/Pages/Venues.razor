@page "/venues"
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject ColorService ColorService

<MudContainer Gutters="false" MaxWidth="MaxWidth.False">
    <MudPaper Class="ma-3 pa-2" Style="z-index: 1; position: absolute">
        <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
            <MudIcon Icon="@Icons.Material.Filled.LocationOn" Color="Color.Primary" />
            <MudSelect Margin="Margin.Dense"Clearable T="string" Variant="Variant.Outlined"
                       Value="newLocation" 
                       ValueChanged="HandleLocationChange"
                       FullWidth Label="Venue"
                       AnchorOrigin="Origin.BottomCenter"
                       OnClearButtonClick="ClearSelection">
                <MudVirtualize Items="venueContents" Context="venue">
                    <MudSelectItem T="string" Value="@venue.Venue">
                        <MudText Typo="Typo.body2">@venue.Venue</MudText>
                    </MudSelectItem>
                </MudVirtualize>
            </MudSelect>
        </MudStack>
    </MudPaper>
    <MudStack id="map"
              Style="width: 100%; height: calc(100vh - 64px); overflow: hidden">
    </MudStack>
</MudContainer>
<style>
    :root {
        color: @ColorService.SelectedColor; /* Default color */
    }
</style>
@code {
    private readonly string API_URL = APIService.Palaro2026API;
    private string mapboxToken = MapBoxService.mapboxToken;
    private string? newLocation;
    private string? selectedLocation;
    private VenuesContents? selectedVenue; // Changed to store the selected venue
    private List<VenuesContents>? venueContents;

    protected override void OnInitialized()
    {
        ColorService.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        ColorService.OnChange -= StateHasChanged;
    }

    //API/Venues/Venue
    public class VenuesContents
    {
        public string? Venue { get; set; }
        public decimal? Latitude { get; set; }
        public decimal? Longitude { get; set; }
    }

    private async Task GetVenues()
    {
        try
        {
            using HttpClient httpClient = new HttpClient();
            HttpResponseMessage httpResponse = await httpClient.GetAsync($"{API_URL}/Venues/Venue")!;
            httpResponse.EnsureSuccessStatusCode(); // Ensure a successful response

            using var responseStream = await httpResponse.Content.ReadAsStreamAsync();
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            venueContents = await JsonSerializer.DeserializeAsync<List<VenuesContents>>(responseStream, options);

            StateHasChanged();
        }
        catch (HttpRequestException ex)
        {
            // Handle exception, log, or display an error message
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
    }

    // Method to clear the selection
    private async void ClearSelection()
    {
        newLocation = null; // Clear the newLocation
        selectedLocation = null; // Clear selectedLocation as well

        // Clear the route from the map via JS interop
        await JSRuntime.InvokeVoidAsync("clearRoute");

        // Center the map back to user location or default location
        await JSRuntime.InvokeVoidAsync("centerMap", null); // Pass null to center on the default location
    }

    // Method to handle location change
    private async Task HandleLocationChange(string? selectedVenue)
    {
        // Ensure newLocation is not null or empty
        if (string.IsNullOrEmpty(selectedVenue))
        {
            return;
        }

        newLocation = selectedVenue;  // Update newLocation to the selected value
        selectedLocation = newLocation; // Optional: keep this if needed for other purposes

        // Find the selected venue from the Venues list
        this.selectedVenue = venueContents?.FirstOrDefault(venue => venue.Venue == newLocation);

        if (this.selectedVenue != null && this.selectedVenue.Latitude.HasValue && this.selectedVenue.Longitude.HasValue)
        {
            // Call JavaScript to provide directions with coordinates
            await JSRuntime.InvokeVoidAsync("showDirections", new object[] {
                new decimal[] { (decimal)this.selectedVenue.Longitude.Value, (decimal)this.selectedVenue.Latitude.Value } // Destination coordinates
    });
        }
        else
        {
            Console.WriteLine("No matching venue found or invalid coordinates.");
        }
    }

    // Method to initialize the map on the first render
    protected override async Task OnInitializedAsync()
    {
        await ColorService.InitializeAsync();
        await GetVenues();
        await JSRuntime.InvokeVoidAsync("initializeMap", "map", mapboxToken, venueContents);
    }
}

